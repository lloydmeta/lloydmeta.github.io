<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Macros | BeachApe.]]></title>
  <link href="https://beachape.com/blog/categories/macros/atom.xml" rel="self"/>
  <link href="https://beachape.com/"/>
  <updated>2016-03-05T18:43:25+09:00</updated>
  <id>https://beachape.com/</id>
  <author>
    <name><![CDATA[Lloyd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Enumeratum: Sealed Trait Enums for Scala]]></title>
    <link href="https://beachape.com/blog/2015/02/11/enumeratum-sealed-trait-enums-for-scala/"/>
    <updated>2015-02-11T16:47:00+09:00</updated>
    <id>https://beachape.com/blog/2015/02/11/enumeratum-sealed-trait-enums-for-scala</id>
    <content type="html"><![CDATA[<p>If you've been working with Scala for a while, you might have come across a few "problems" with the built in <code>Enumeration</code> that's provided out-of-the-box.  This is especially true if you have colleagues who come from a Java background and yearn for the Java-style <code>Enum</code> that gave them lots of power and flexibility.</p>

<p>A quick search on the internet for "Scala enumeration alternative" will yield a lot of results (perhaps on StackOverflow) where people have cooked up their own implementation of enumerations, usually built on <code>sealed traits</code>. Personally, I found most of them to be either too inconvenient to use, too over-powered, or too complicated, and I really didn't want to have to copy-paste enum-related code into all my projects.</p>

<p>Thus <a href="https://github.com/lloydmeta/enumeratum">Enumeratum</a> was born.</p>

<!-- more -->


<p><a href="https://github.com/lloydmeta/enumeratum">Enumeratum</a> aims to be simple to use, idiomatic, small (LoC), yet flexible enough to allow Scala devs to make power enums if they so wish. It is also Mavenised for easy import into any project.</p>

<p>To use it, simply <a href="https://github.com/lloydmeta/enumeratum#sbt">add it as a dependency</a></p>

<p>```
libraryDependencies ++= Seq(</p>

<pre><code>"com.beachape" %% "enumeratum" % "1.0.0",
"com.beachape" %% "enumeratum-play" % "1.0.0" // if you are using Play and want to avoid boilerplate
</code></pre>

<p>)
```</p>

<p>Then</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>Enumeratum example code (enumeratum_example.scala)</span> <a href='/downloads/code/scala/enumeratum_example.scala'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="c1">// For use in a REPL</span>
</span><span class='line'>
</span><span class='line'><span class="k">import</span> <span class="nn">enumeratum._</span>
</span><span class='line'>
</span><span class='line'><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Phone</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">call</span><span class="o">(</span><span class="n">number</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">case</span> <span class="k">object</span> <span class="nc">Phone</span> <span class="k">extends</span> <span class="nc">Enum</span><span class="o">[</span><span class="kt">Phone</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">case</span> <span class="k">object</span> <span class="nc">Android</span> <span class="k">extends</span> <span class="nc">Phone</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">call</span><span class="o">(</span><span class="n">number</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="s">&quot;This is Larry Page.&quot;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">case</span> <span class="k">object</span> <span class="nc">Iphone</span> <span class="k">extends</span> <span class="nc">Phone</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">call</span><span class="o">(</span><span class="n">number</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="s">&quot;This is Steve Jobs.&quot;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">case</span> <span class="k">object</span> <span class="nc">WindowsPhone</span> <span class="k">extends</span> <span class="nc">Phone</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">call</span><span class="o">(</span><span class="n">number</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="s">&quot;This is Bill Gates.&quot;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">val</span> <span class="n">values</span> <span class="k">=</span> <span class="n">findValues</span>
</span><span class='line'>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">import</span> <span class="nn">Phone._</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Use as needed.</span>
</span><span class='line'>
</span><span class='line'><span class="k">val</span> <span class="n">myPhone</span> <span class="k">=</span> <span class="nc">Iphone</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Get exhaustive match warnings</span>
</span><span class='line'><span class="k">def</span> <span class="n">rate</span><span class="o">(</span><span class="n">phone</span><span class="k">:</span> <span class="kt">Phone</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">phone</span> <span class="k">match</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="nc">Android</span> <span class="k">=&gt;</span> <span class="s">&quot;Great!&quot;</span>
</span><span class='line'>  <span class="k">case</span> <span class="nc">Iphone</span> <span class="k">=&gt;</span> <span class="s">&quot;Awesome!&quot;</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/*</span>
</span><span class='line'><span class="cm">&lt;console&gt;:17: warning: match may not be exhaustive.</span>
</span><span class='line'><span class="cm">It would fail on the following input: WindowsPhone</span>
</span><span class='line'><span class="cm">*/</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>You get nice things like exhaustive match warnings at compile-time, enums with methods, no more Enum-value type erasure, and other nice stuff.</p>

<h2>How it works</h2>

<p>Some of the solutions for custom enums out there are based on macros that reflect at compile time using <code>knownDirectSubclasses</code> to find enum values, but as of writing, there is a <a href="https://issues.scala-lang.org/browse/SI-7046">2 year old bug</a> for that method.</p>

<p>As a result, <a href="https://github.com/lloydmeta/enumeratum">Enumeratum</a> uses another method of finding enum values: looking in an enclosed object to find the enum values. The macro behind <code>findValues</code> does this for you so that you don't have to maintain your own collection of enum values, which is both error-prone and tedious.</p>

<h2>Play</h2>

<p>If you want to use <a href="https://github.com/lloydmeta/enumeratum">Enumeratum</a> in a Play app, you may as well add <a href="https://github.com/lloydmeta/enumeratum#play-2"><code>enumeratum-play</code></a> as a dependency instead so that you can use the <code>PlayEnum[A]</code> trait (instead of <code>Enum[A]</code>), which will give you nice things like QueryStringBinders, PathBinders, form mappers, and Json Reads/Writes/Formats. This means less boilerplate in your project, which is A Good Thing, right?</p>

<h2>Limitations</h2>

<p>There are a few limitations with Enumeratum:</p>

<ul>
<li>Ordinality is not taken care of. From what I've seen, this is one of the least-used functions of Enums in general. That said, nothing is stoping you from defining an <code>Ordering</code> in your companion object for your sealed trait.</li>
<li>Because the Enum values are case objects, they will be inferred to have their own specific type, which may cause problems with compilation for typeclasses that are not contravariant. In that case, simply help the compiler by adding a type (e.g. <code>val myPhone: Phone = Iphone</code>)</li>
<li>The method <code>withName</code> relies on the <code>toString</code> method of the Enum values for lookup. Make sure to override this if you have specific requirements.</li>
</ul>


<h2>Enjoy</h2>

<p>I hope <a href="https://github.com/lloydmeta/enumeratum">Enumeratum</a> can help you out of your <code>Enumeration</code> woes. Have a look, play around, and send a PR or two !</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scala Unless-when via Macros]]></title>
    <link href="https://beachape.com/blog/2014/08/11/scala-unless-when-via-macros/"/>
    <updated>2014-08-11T18:41:00+09:00</updated>
    <id>https://beachape.com/blog/2014/08/11/scala-unless-when-via-macros</id>
    <content type="html"><![CDATA[<p>Last week, I decided to take a stab at learning <a href="http://scalamacros.org/">Scala macros</a>. I had played around with macros when I wrote Scheme for a living (yes, believe it or not, these places exist...and existed long before Clojure made Lisp hip again), but the complexity of Scala's macros always put me off (if you don't believe me, check out the example given in the offical docs for a simple <a href="http://docs.scala-lang.org/overviews/macros/overview.html#a-complete-example">print macro</a>).</p>

<p>In Scala, things are not so simple, but with the introduction of <a href="docs.scala-lang.org/overviews/macros/quasiquotes.html">quasiquotes</a> and some refinements brought by Scala 2.11, things are smoother. Still, for a guy like me, the documentation was both sparse and DRY. Since I learn best when I'm actively engaged in building something, I decided to try writing the <a href="http://clhs.lisp.se/Body/m_when_.htm">run-of-the-mill unless-when</a> macros in Scala.</p>

<p>This post aims to summarise my journey towards implementing <a href="https://github.com/lloydmeta/unless-when">unless-when</a> and hopefully along the way make Scala macros accessible, at least at an introductory level, for Most People. There are already a few Scala macro blog posts out there but another one can't hurt.</p>

<!-- more -->


<p><em>Note</em>: this blog post aims to explore macros as they are usable in Scala 2.10+. It also focuses on implementing macros with quasiquotes, as using them is more human-friendly than manually constructing Abstract Syntax Trees (AST).</p>

<h2>Goal</h2>

<p>For those unfamiliar with <code>when</code> and <code>unless</code>: the basic idea is that <code>when</code> is an <code>if</code> without an else, and <code>unless</code> is it's opposite. The main reason for their existence is to make code more readable by adding a tiny bit of syntatic sugar. Without further ado, an example of what we want to achieve</p>

<p>```scala
/<em>
  This should replace if (true) { block of code }
</em>/
when (true) {
  // block of code
}</p>

<p>/<em>
  This should replace if (!true) { do something }
</em>/
unless (false) {
  // block of code
}
```</p>

<p>Since we're writing Scala, it would be nice if these constructs returned something useful; using the <a href="http://www.scala-lang.org/api/current/scala/Option.html">Option</a> monad seems reasonable: If the block is run, we return the result in a Some and otherwise return a None. <a href="http://danielwestheide.com/blog/2012/12/19/the-neophytes-guide-to-scala-part-5-the-option-type.html">This tutorial</a> is a good guide for Options in case you are unfamiliar with the concept.</p>

<h2>Macro-y basics</h2>

<p>Taking a look at the documentation, you will quickly notice the general pattern for implementing a simple Scala macro</p>

<p>```scala
import scala.language.experimental.macros
import scala.reflect.macros._</p>

<p>object Example {
  def meth<a href="x:%20A">A</a>: A = macro implRef[A]</p>

<p>...</p>

<p>  def implRef<a href="c:%20Context">A: c.WeakTypeTag</a>(x: c.Expr[A]): c.Expr[A] = ...
}
```
What does this mean? Let's break it down:</p>

<ul>
<li><code>import scala.language.experimental.macros</code> and <code>import scala.reflect.macros._</code> are standard Scala imports that allow us to play around with macros. What's not listed in this example is the declaration that your project depends on <code>scala-reflect</code>. You can do so by adding the following to your build.sbt:

<ul>
<li><code>libraryDependencies ++= Seq("org.scala-lang" % "scala-reflect" % scalaVersion.value)</code></li>
</ul>
</li>
<li><code>def meth[A](x: A): A</code> this is still just normal Scala code that we would normally see. It simply declares a method belonging to the Example singleton that is parameterised on the input type, and we want to make sure that the output type matches this type (e.g. if we invoke <code>meth</code> with an <code>Int</code>, we expect the output to be an <code>Int</code> because that is the contract of the method). For more info on writing parametric polymorphism, please check out <a href="Parametric%20polymorphism">this guide</a>:</li>
<li><code>macro implRef[A]</code> this is where things start looking macro-ish. The <code>macro</code> keyword lets the compiler know that the body of this method is going to be implemented via a macro definition, in this case <code>implRef</code>.</li>
<li><code>def implRef[A: c.WeakTypeTag](c: Context)(x: c.Expr[A]): c.Expr[A]</code> .. wow. This itself needs to be broken down:

<ul>
<li><code>def implRef[A: c.WeakTypeTag]</code> The first part <code>def implRef</code> is still standard Scala</li>
<li><code>(c: Context)</code> (we'll cover <code>[A: c.WeakTypeTag]</code> in a bit). In this part, <code>(c: Context)</code> declares that the first argument passed to the macro implementation must be a Context. This is a requirement for playing around with Scala macros, and is actually passed by the compiler when it invokes macro expansion, so that you can write code that accesses the compiler API.</li>
<li><code>[A: c.WeakTypeTag]</code> This is a bit mischievous because we combine Scala-shorthand for typeclasses with macro-magic. This probably deserves a post in and of itself, but for now, please consider this to mean "A is a type parameter passed during macro invocation, but we must ALSO have in scope a WeakTypeTag coming from the Context that is parameterised to type A, which can be written in full as c.WeakTypeTag[A]". This WeakTypeTag business is required so that we can pass along the type parameter from <code>meth</code> into the <code>implRef</code> macro expansion implementation, allowing us to have a type parameterised macro definition.

<ul>
<li>For more information on type classes and the shorthand we use here, I highly recommend this <a href="danielwestheide.com/blog/2013/02/06/the-neophytes-guide-to-scala-part-12-type-classes.html">blog post on type classes</a></li>
</ul>
</li>
<li><code>(x: c.Expr[A])</code> means that the first non-Context parameter of the macro implementation (remember that the first one is always taken by the compiler and must be a Context) is <code>x</code> and it is a <code>c.Expr[A]</code>. It is important that the name of the parameter matches that used in the invoking method (see how <code>meth</code> also has <code>x</code> as the first parameter). <code>c.Expr</code> is type of object that wraps the abstract syntax tree that represents the input to the invoking function, and it is typed to A.

<ul>
<li><em>NOTE:</em> since the argument's type is <code>c.Expr</code> (essentially an abstract syntax tree), any expression passed to the method <code>meth</code> actually may not get invoked or evaluated even though it is not a <a href="http://daily-scala.blogspot.jp/2009/12/by-name-parameter-to-function.html">pass-by-name parameter</a>. In other words, while the macro is expanding, it <strong>acts</strong> like a pass-by name parameter and is "lazy".</li>
</ul>
</li>
<li><code>: c.Expr[A]</code> all this means is that the result of the macro expansion is also a <code>c.Expr</code> type parameterised to A.</li>
</ul>
</li>
</ul>


<h2>Quasiquotes</h2>

<p>Quasiquotes are not a Scala-exclusive construct, and a Google search will show that they are used in other languages that support metaprogramming, like Scheme.</p>

<p>In short, they offer the macro programmer an easy way to manipulate or create abstract syntax trees without having to build them manually. This makes them extremely helpful in Scala because:
  1. Scala syntax does not map to ASTs easily like Lisps
  2. Scala is typed, which means your manually-built AST also needs typing...which wraps non-macro-land types (notice how a normal type parameter like <code>[A]</code> becomes <code>c.Expr[A]</code> ... that's twice as many characters  !)</p>

<p>Quasiquotes allow us to use <a href="http://docs.scala-lang.org/overviews/core/string-interpolation.html">string-interpolation-like syntax</a> to interpolate elements into a tree as we define it.</p>

<p>For example:</p>

<p>```scala
scala> val aquasiquote = q"a quasiquote"
aquasiquote: universe.Select = a.quasiquote</p>

<p>scala> val tree = q"i am { $aquasiquote }"
tree: universe.Tree = i.am(a.quasiquote)
```
The above example was taken from the <a href="http://docs.scala-lang.org/overviews/quasiquotes/intro.html">official documentation on quasiquotes</a>, which I highly recommend you take a look at if you find the rest of this post hard to follow.</p>

<h2>Implementation</h2>

<p>For <code>when</code>, we know that we roughly want the following:</p>

<p><code>scala
when (someCondition) { result }
</code></p>

<p>To expand via our macro into the following (yes we are using an inline if .. if you don't like it, pretend we didn't)</p>

<p><code>scala
if (someCondition) Some(result) else None
</code></p>

<p>Using what we know, the following should work:</p>

<p>```scala
import scala.language.experimental.macros
import scala.reflect.macros._</p>

<p>object Example {</p>

<p>  def when<a href="p:%20Boolean">A</a>(f: A): Option[A] = macro whenImp[A]</p>

<p>  def whenImp<a href="c:%20Context">A: c.WeakTypeTag</a>(p: c.Expr[Boolean])(f: c.Expr[A]): c.Expr[Option[A]] = {</p>

<pre><code>import c.universe._
c.Expr[Option[A]](q"if ($p) Some($f) else None")
</code></pre>

<p>  }
}
```</p>

<p>Implementing <code>unless</code> is left as an exercise for the reader :)</p>

<h2>Trying it out</h2>

<p>Putting the above into a Scala REPL (you will probably need to use <code>:paste</code> mode) will prove that it works.</p>

<p>For example:</p>

<p>```scala
scala> import Example.<em>
import Example.</em></p>

<p>when(true)(3)
res1: Option[Int] = Some(3)
```</p>

<p>Also, remember that since our <code>when</code> is backed by a macro, the <code>f</code> argument (our block) passed to the second parameter list, behaves "lazily" and won't execute if our predicate<code>p</code> returns false. This is because when <code>when</code> is invoked, the compiler knows to pass the entire AST for that block parameter (well, wrapped inside a <code>c.Expr</code>) to our macro, which interpolates the it into the final tree.</p>

<p>For the performance-conscious, this means that we get "lazy" for free; that is, without using Scala's call-by-name parameter feature, which, although nice to use in many cases, <em>does</em> incur some run-time performance penalty because it is implemented by instantiating anonymous classes (see <a href="http://infoscience.epfl.ch/record/128135/files/paper.pdf">this paper</a> for more information about the performance cost of call-by-name parameters .. among other performance-related Scala things).</p>

<h2>unless-when library</h2>

<p>I've put the above into a library and included trailing variants of <code>when</code> and <code>unless</code> as bonuses (Rubyists should be familiar with these).</p>

<p>You can find the lib <a href="https://github.com/lloydmeta/unless-when">here on Github</a>. It is fully tested and Mavenised for easy out-of-the-box usage.</p>

<h2>Conclusion</h2>

<p>I hope this post has been helpful in giving a simple, but full example of how to get started with macros in Scala. If you spot any errors, have questions or suggestions, please feel free to leave a comment!</p>
]]></content>
  </entry>
  
</feed>
