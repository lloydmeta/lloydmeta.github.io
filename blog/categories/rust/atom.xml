<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rust | BeachApe.]]></title>
  <link href="https://beachape.com/blog/categories/rust/atom.xml" rel="self"/>
  <link href="https://beachape.com/"/>
  <updated>2025-10-04T14:54:23+00:00</updated>
  <id>https://beachape.com/</id>
  <author>
    <name><![CDATA[Lloyd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Porting InstaBeach to Rust: A 10-Year-Old Play App Goes Serverless]]></title>
    <link href="https://beachape.com/blog/2025/10/04/porting-instabeach-to-rust-a-10-year-old-play-app-goes-serverless/"/>
    <updated>2025-10-04T06:12:00+00:00</updated>
    <id>https://beachape.com/blog/2025/10/04/porting-instabeach-to-rust-a-10-year-old-play-app-goes-serverless</id>
    <content type="html"><![CDATA[<p>The Japanese yen‚Äôs exchange rate took a nosedive this year, and my monthly cloud costs for running a tiny beach recommendation site ballooned from ‚ÄúI can ignore this‚Äù to ‚Äúthis is getting silly‚Äù.  <a href="https://instabeach.io">instabeach.io</a><sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>, a site I built a decade ago to help my wife and me find beach destinations based on weather and travel dates, was running on a Kubernetes cluster that started to cost more and more per month.  Time for a change.</p>

<p><img class="center" src="/images/instabeach-io-rs.png" title="‚ÄòInstabeach share card‚Äô" ></p>

<!-- more -->

<h2 class="no_toc" id="overview">Overview</h2>
<ul id="markdown-toc">
  <li><a href="#the-origin-story">The origin story</a></li>
  <li><a href="#the-deployment-journey">The deployment journey</a>    <ul>
      <li><a href="#then-the--">Then the ¬• üìâ</a></li>
    </ul>
  </li>
  <li><a href="#why-rust-and-lambda">Why Rust and Lambda?</a></li>
  <li><a href="#engineering-decisions-and-tradeoffs">Engineering decisions and tradeoffs</a>    <ul>
      <li><a href="#cargo-lambda-one-web-app-not-many-functions">Cargo Lambda: one web app, not many functions</a></li>
    </ul>
  </li>
  <li><a href="#tokiomain">[tokio::main]</a>    <ul>
      <li><a href="#no-database-csv-driven-codegen">No database: CSV-driven codegen</a></li>
      <li><a href="#rust-embed-no-s3-no-problems">rust-embed: no S3, no problems</a></li>
      <li><a href="#heavy-caching-and-rate-limiting-at-the-cdn">Heavy caching and rate limiting at the CDN</a></li>
      <li><a href="#terraform-and-terraform-local-for-deployment">Terraform and terraform-local for deployment</a></li>
      <li><a href="#the-compilation-time-tradeoff">The compilation time tradeoff</a></li>
      <li><a href="#results-and-reflections">Results and reflections</a></li>
    </ul>
  </li>
</ul>

<h2 id="the-origin-story">The origin story</h2>

<p>Before having kids and the pandemic, my wife and I loved going on beach holidays every year.  The problem was finding the perfect beach for us given a specific timeframe, our preferred temperature range, and some rough understanding of wet and dry seasons.  Searching through travel blogs and weather sites was tedious, so I did what any reasonable software engineer would do: I spent far more time building a solution than I would have spent doing the manual research.</p>

<p>I wrote InstaBeach in Scala using the Play Framework because I genuinely love the language.  Play made it easy to build a clean MVC application with reasonable performance.  The site worked well, and I was happy with it.</p>

<h2 id="the-deployment-journey">The deployment journey</h2>

<p>The app‚Äôs deployment history mirrors the evolution of cloud platforms and my own curiosity:</p>

<ol>
  <li><strong>Heroku (2015-2018)</strong>: Initially deployed to Heroku because it was free and dead simple.  Git push, and you‚Äôre done.  This was perfect for a side project that maybe five people used (mostly me).</li>
  <li><strong>Docker Swarm on AWS (2018-2020)</strong>: Around when Heroku killed their free tier, I moved to a 3-node Docker Swarm cluster on AWS.  This didn‚Äôt save me any money, but I got more compute and control for the same-ish cost, though it required more maintenance.  Still, it was cheap enough that I didn‚Äôt think about it much, especially since I already was running several side projects at this time on it.</li>
  <li><strong>GCP Kubernetes (2020-2025)</strong>: I wanted to learn k8s properly, so I migrated to GKE, which was cheap-ish at the time. Plus it allowed me to avoid thinking about how to maintain my Docker Swarm cluster (<a href="https://github.com/moby/swarmkit/issues/1429">which had issues I found out about over time‚Ä¶</a>)</li>
</ol>

<h3 id="then-the--">Then the ¬• üìâ</h3>

<p>Then 2022 happened.  The Japanese yen went from around ¬•110 to the dollar to ¬•150+<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>. For a side project that generates zero revenue and gets minimal traffic, this got absurd. I waited for a while to see if it would go back, but today it still sits at around ¬•147.</p>

<p>Plus, I wasn‚Äôt maintaining the k8s cluster well anyway.  Security patches were piling up, I had outdated Scala dependencies, and the whole thing felt like technical debt that was actively costing me money.  Plus, this year I finally allowed myself to upgrade from my iPhone X since it was no longer getting OS nor proper app updates, so I decided to rethink the architecture and try to save some $$.</p>

<h2 id="why-rust-and-lambda">Why Rust and Lambda?</h2>

<p>I wanted to move to AWS Lambda for one simple reason: the generous free tier<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>.  Lambda gives you 1 million free requests per month and 400,000 GB-seconds of compute time.  For a low-traffic site like InstaBeach, this meant potentially zero ongoing costs.</p>

<p>But Lambda has a problem: cold starts.  When a function hasn‚Äôt been invoked recently, AWS has to spin up a new environment, load your code, and initialise the runtime.  This can add hundreds of milliseconds or even seconds to your response time<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>.</p>

<p>Rust solves this.  Compiled Rust binaries have the fastest cold start times of any Lambda runtime<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>, typically 20-50ms.  Combined with excellent runtime performance, Rust lets you maximise the free tier while keeping response times snappy. Plus, it doesn‚Äôt hurt that I‚Äôve been a fan for years, and <a href="https://www.arewewebyet.org">Rust is web</a>.</p>

<h2 id="engineering-decisions-and-tradeoffs">Engineering decisions and tradeoffs</h2>

<p>Porting InstaBeach to Rust wasn‚Äôt just a matter of translation.  I made several architectural decisions to optimise for Lambda‚Äôs constraints and the free tier.</p>

<h3 id="cargo-lambda-one-web-app-not-many-functions">Cargo Lambda: one web app, not many functions</h3>

<p>Instead of splitting the application into multiple Lambda functions (one per endpoint), I used <a href="https://www.cargo-lambda.info">cargo lambda</a><sup id="fnref:6"><a href="#fn:6" rel="footnote">6</a></sup> to deploy a single <a href="https://github.com/tokio-rs/axum">Axum</a> web application.  This lets me write normal web application code with routing, middleware, and all the conveniences of a web framework, while still deploying to Lambda.</p>

<p>Here‚Äôs how the main entry point looks:</p>

<p>```rust
use instabeach::create_app;
use lambda_http::{run, Error};
use std::env;
use tracing::info;</p>

<h1 id="tokiomain">[tokio::main]</h1>
<p>async fn main() -&gt; Result&lt;(), Error&gt; {
    // If you use API Gateway stages or Lambda Function URLs, the Rust Runtime will include stage info
    // as part of the path that your application receives.
    // Setting the following environment variable removes the stage from the path.
    // i.e with: <code>GET /test-stage/assets/css/main.css</code> without: <code>GET /assets/css/main.css</code>
    env::set_var(‚ÄúAWS_LAMBDA_HTTP_IGNORE_STAGE_IN_PATH‚Äù, ‚Äútrue‚Äù);</p>

<pre><code>tracing_subscriber::fmt()
    .with_target(false)
    .without_time()
    .init();

let app = create_app().await?;

info!("Starting InstaBeach Lambda function");
run(app).await } ```
</code></pre>

<p>The <code>create_app()</code> function returns an Axum router with all the endpoints configured.  Cargo Lambda handles the integration with the Lambda runtime, and I can test the whole thing locally with <code>cargo lambda watch</code> on port 9000.</p>

<h3 id="no-database-csv-driven-codegen">No database: CSV-driven codegen</h3>

<p>Databases add complexity and cost.  Even serverless options like DynamoDB have charges for read/write capacity.  For InstaBeach, the data is essentially static: beach destinations, their locations, temperature ranges, and wet/dry seasons.</p>

<p>Instead of a database, I use a CSV file as the source of truth.  At build time, a code generation script reads the CSV and generates Rust structs with all the destination data embedded directly into the binary.  This gives me an in-memory ‚Äúdatabase‚Äù with zero runtime I/O and zero ongoing costs.</p>

<p>From a CSV like this</p>

<p><code>
id,name,country,airport_code,image_path,jan_season,feb_season,mar_season,apr_season,may_season,jun_season,jul_season,aug_season,sep_season,oct_season,nov_season,dec_season,jan_min_temp,jan_max_temp,feb_min_temp,feb_max_temp,mar_min_temp,mar_max_temp,apr_min_temp,apr_max_temp,may_min_temp,may_max_temp,jun_min_temp,jun_max_temp,jul_min_temp,jul_max_temp,aug_min_temp,aug_max_temp,sep_min_temp,sep_max_temp,oct_min_temp,oct_max_temp,nov_min_temp,nov_max_temp,dec_min_temp,dec_max_temp,info_link,image_author,image_url
bali,Bali,Indonesia,DPS,destinations/bali.jpg,Wet,Wet,Wet,Dry,...,Lloyd,https://beachape.com
</code></p>

<p>Here‚Äôs a snippet from the generated destination data:</p>

<p><code>rust
Destination {
    id: "bali".to_string(),
    name: "Bali".to_string(),
    country: Country::ID,
    airport_code: AirportCode::DPS,
    season_ranges: SeasonRanges {
        jan: Season::Wet,
        feb: Season::Wet,
        mar: Season::Wet,
        apr: Season::Dry,
        // ... more months
    },
    monthly_temp_averages: MonthlyTemperatureAverages {
        jan: TemperatureRange::new(25.0, 30.0),
        feb: TemperatureRange::new(25.0, 30.0),
        // ... more months
    },
    image: Image {
        path: "destinations/bali.jpg".to_string(),
        is_packaged: true,
        credit: Some(Credit {
            name: "Bali".to_string(),
            author: "Lloyd".to_string(),
            kind: AttributionType::Image,
            url: Some("https://beachape.com".to_string()),
        }),
    },
    info_link: None,
}
</code></p>

<p>The entire dataset compiles into the binary, and lookups are just array iterations or hash map lookups in memory.  Fast, simple, and free.</p>

<h3 id="rust-embed-no-s3-no-problems">rust-embed: no S3, no problems</h3>

<p>Most serverless applications store static assets (CSS, JavaScript, images) in S3 and serve them through some CDN.  This makes sense for large applications, but adds complexity and cost.</p>

<p>Instead, I use <a href="https://docs.rs/rust-embed">rust-embed</a> to embed all static assets directly into the binary at compile time.  Here‚Äôs how the asset handler looks:</p>

<p>```rust
use rust_embed::RustEmbed;</p>

<p>/// Embedded assets using rust-embed
/// All assets are embedded at compile time automatically
#[derive(RustEmbed)]
#[folder = ‚Äúsrc/assets/‚Äù]
struct Assets;</p>

<p>/// Handler for serving static assets
pub async fn serve_asset(Path(asset_path): Path<string>) -&gt; Result&lt;Response, AppError&gt; {
    if let Some(content) = Assets::get(&amp;asset_path) {
        let mime_type = get_mime_type(&amp;asset_path);
        let body = content.data;</string></p>

<pre><code>    Ok(Response::builder()
        .status(StatusCode::OK)
        .header(header::CONTENT_TYPE, mime_type)
        .header(header::CACHE_CONTROL, "public, max-age=31536000, immutable")
        .header(header::CONTENT_LENGTH, body.len())
        .body(body.into())
        .unwrap())
} else {
    Err(AppError::not_found(format!(
        "Asset {} not found",
        asset_path
    )))
} } ```
</code></pre>

<p>In release builds, <code>Assets::get()</code> returns the file contents from the embedded binary.  In development, it reads from the filesystem.  This saves S3 costs and reduces the number of moving parts in production.</p>

<p>The tradeoff is a larger binary size.  The InstaBeach binary is about 93MB, which exceeds Lambda‚Äôs 50MB direct upload limit.  But that‚Äôs fine‚Äîwe can upload via S3 during deployment, and the binary still fits well within Lambda‚Äôs 250MB limit.</p>

<h3 id="heavy-caching-and-rate-limiting-at-the-cdn">Heavy caching and rate limiting at the CDN</h3>

<p>To minimise Lambda invocations and prevent abuse, I rely heavily on Cloudflare caching and rate limiting (also <a href="https://developers.cloudflare.com/cache/plans/">free</a>).  Static assets are cached for a year (they‚Äôre immutable anyway), and API responses are cached for 5 minutes.</p>

<p>This means most requests never hit Lambda at all.  They‚Äôre served directly from Cloudflare‚Äôs edge locations, which is both faster for users and cheaper for me.</p>

<h3 id="terraform-and-terraform-local-for-deployment">Terraform and terraform-local for deployment</h3>

<p>Infrastructure is managed with <a href="https://www.terraform.io/">Terraform</a>.  The Terraform configuration defines the Lambda function, IAM roles, Cloudflare configuration, and DNS records.</p>

<p>For local testing, I use <a href="https://github.com/localstack/terraform-local">tflocal</a> with <a href="https://www.localstack.cloud/">LocalStack</a>.  This lets me deploy and test the entire infrastructure locally without touching AWS.  It‚Äôs brilliant for fast iteration:</p>

<p><code>bash
# Start LocalStack and provision it
make start_dev_env provision_dev_env
</code></p>

<p>The Terraform module for the Lambda function handles building the Rust binary, uploading to S3, and creating the function using <a href="https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/lambda_function">aws_lambda_function</a>:</p>

<p>```
resource ‚Äúaws_s3_object‚Äù ‚Äúlambda_zip‚Äù {
  bucket = var.deployment_bucket
  key    = ‚Äú${var.function_name}/bootstrap-${local.code_hash}.zip‚Äù
  # Use different paths for different architectures and build modes
  source = local.lambda_zip_path</p>

<p>depends_on = [null_resource.rust_build]
}</p>

<p>resource ‚Äúnull_resource‚Äù ‚Äúrust_build‚Äù {
  triggers = {
    code_diff = local.code_hash
  }</p>

<p>provisioner ‚Äúlocal-exec‚Äù {
    working_dir = var.rust_src_path
    command = join(‚Äú ‚Äú, [
      ‚Äúcargo lambda build‚Äù,
      var.build_mode == ‚Äúrelease‚Äù ? ‚Äú‚Äìrelease‚Äù : ‚Äú‚Äù,
      var.architecture == ‚Äúx86_64‚Äù ? ‚Äú‚Äìx86-64‚Äù : ‚Äú‚Äìarm64‚Äù,
      ‚Äú‚Äìoutput-format zip‚Äù
    ])
  }
}</p>

<p>// Somewhere else</p>

<p>output ‚Äúlambda_function_url‚Äù {
  value = aws_lambda_function_url.this.function_url
}
```</p>

<p>Nothing crazy, and most of the code is visible at <a href="https://github.com/lloydmeta/miniaturs/tree/main/terraform/modules/lambda_rust">miniatu-rs</a>.</p>

<h3 id="the-compilation-time-tradeoff">The compilation time tradeoff</h3>

<p>The big disadvantage of this approach is compilation time.  A release build of the Rust binary takes over 30 minutes on my machine.  This is painful during development, but the tradeoff is worth it:</p>

<ul>
  <li>Zero ongoing costs (within the free tier)</li>
  <li>Fast cold starts (&lt;2 seconds)</li>
  <li>No database or S3 to manage</li>
  <li>Simple deployment and rollback</li>
</ul>

<p>During development, I use <code>cargo lambda watch</code> for fast iteration with debug builds, which compile in under a minute.  Release builds are only for testing in LocalStack and actual production deployments.</p>

<h2 id="results-and-reflections">Results and reflections</h2>

<p>The migration was successful.  InstaBeach now runs entirely within AWS Lambda‚Äôs free tier, costing me nothing per month.  Cold starts are fast enough that I highly doubt anyone can notice, and it feels snappier to me‚Ñ¢.</p>

<p>The Rust ecosystem for web development has matured significantly.  Axum is a joy to work with, cargo lambda makes Lambda deployment trivial, and crates like rust-embed and Askama (for compile-time templates) provide excellent ergonomics.</p>

<p>Would I recommend this approach for every application?  Probably not.  If you have a database, frequent deployments, or need sub-<code>X</code>ms cold starts, you might need a different architecture.  But for small, static-ish applications with low traffic, the combination of Rust and Lambda‚Äôs free tier is hard to beat.</p>

<p>And my monthly cloud bill?  Zero yen, zero pounds, zero dollars.  Just the way I like it.</p>

<h4 class="no_toc" id="footnotes">Footnotes</h4>

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>It‚Äôs really just a very simple calculator for finding beach locations.<a href="#fnref:1" rel="reference">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>And yes, I know that other countries have had it worse. But just look at this <a href="https://www.xe.com/currencycharts/?from=USD&amp;to=JPY&amp;view=10Y">USD to JPY Exchange Rate History</a><a href="#fnref:2" rel="reference">&#8617;</a></p>
    </li>
    <li id="fn:3">
      <p>AWS says Lambda will always have a free tier (‚ÄúThis always free service is on the Free and Paid plan.‚Äù) <a href="https://aws.amazon.com/pm/lambda/">AWS Lambda</a><a href="#fnref:3" rel="reference">&#8617;</a></p>
    </li>
    <li id="fn:4">
      <p>Quite a lot goes into AWS Lambda cold starts, but a high level understanding of the lifecycle can be found at <a href="https://aws.amazon.com/blogs/compute/understanding-and-remediating-cold-starts-an-aws-lambda-perspective/">Understanding AWS Lambda Cold Starts</a><a href="#fnref:4" rel="reference">&#8617;</a></p>
    </li>
    <li id="fn:5">
      <p>Rust is number 1 according to  <a href="https://filia-aleks.medium.com/aws-lambda-battle-2021-performance-comparison-for-all-languages-c1b441005fd1">AWS Lambda Cold Start Performance Comparison</a><a href="#fnref:5" rel="reference">&#8617;</a></p>
    </li>
    <li id="fn:6">
      <p>I already used it and loved it from a previous project, <a href="https://github.com/lloydmeta/miniaturs">miniatu-rs</a><a href="#fnref:6" rel="reference">&#8617;</a></p>
    </li>
  </ol>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Structural Typing in Rust]]></title>
    <link href="https://beachape.com/blog/2021/05/25/structural-typing-in-rust/"/>
    <updated>2021-05-25T21:42:00+00:00</updated>
    <id>https://beachape.com/blog/2021/05/25/structural-typing-in-rust</id>
    <content type="html"><![CDATA[<p>Have you ever wanted to write a structurally typed function in Rust? Do you spend a lot of time and effort getting your Rust <code>struct</code>s <em>just so</em>, and want to DRY-out data access for common field paths without declaring a new <code>trait</code> and implementing it for each struct (let‚Äôs say, <code>Cat</code> and <code>Dog</code> both have a <code>name: String</code> field)? If so, read on.</p>

<p><img class="center" src="/images/shape-sorter-child-with-hammer.gif" title="‚ÄòA child trying and failing to use a hammer to bash a shape into a shape sorter toy‚Äô" ></p>

<p>This post talks about how we can leverage <code>LabelledGeneric</code> to build <code>Path</code> traversers (functionally similar to <a href="https://en.wikibooks.org/wiki/Haskell/Lenses_and_functional_references">lenses</a>), and use them to write clean and performant structurally typed functions with all the compile-time safety that you‚Äôve come to expect from Rust.</p>

<!-- more -->

<h2 class="no_toc" id="re-radio-silence">Re: radio silence</h2>

<p>It‚Äôs been a while (4 years!) since I last updated this blog. Why?</p>

<ul>
  <li>I started working on the <a href="https://cloud.elastic.co">Cloud</a> SWE team at <a href="https://www.elastic.co">Elastic</a> (we‚Äôre <a href="https://grnh.se/baff303b1">hiring!</a>). I‚Äôve been busy leading project teams, implementing features, and writing (and deleting!) lots of Scala code (no Rust though, sadly üò≠)</li>
  <li>My kid gained sentience: Around the same time, my daughter turned 2, and it‚Äôs just been a complete whirlwind of activities, learning, viruses, emotions, etc. It‚Äôs been awesome and I wouldn‚Äôt trade it for the world, but people are DOWNRIGHT LYING if they claim having kids doesn‚Äôt change anything.</li>
  <li>2020: Covid was a big one, but the whole year felt like a trainwreck in slow motion ‚Ä¶ if the train was pulling dumpster fires.</li>
</ul>

<p>Lastly, I just didn‚Äôt have the oomph to write a post that describes <code>transmogrify()</code> to follow up on <a href="/blog/2017/04/12/boilerplate-free-struct-transforms-in-rust/">the post on Struct transforms</a>. <code>Transmogrifier</code>, which allows flexibile <a href="https://docs.rs/frunk/0.3.0/frunk/labelled/trait.Transmogrifier.html#example">recursive transformation between similarly-structured <code>structs</code></a>, was added over 2.5 years ago, but writing about it was ‚Ä¶ intimidating.</p>

<p>Still, I recently decided to <em>try</em> to start writing again, so I picked a topic that‚Äôs slightly simpler, but related: <a href="https://docs.rs/frunk/0.3.2/frunk/path/index.html"><code>Path</code></a>, which introduced <a href="https://blog.rust-lang.org/2015/05/11/traits.html">zero-overhead</a> structurally-typed functions that you could use with normal <code>struct</code>s to stable Rust <a href="https://github.com/lloydmeta/frunk/blob/master/CHANGELOG.md#024---2019-02-10">back in Februrary of 2019</a> <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>.</p>

<p>Is the post late? Yes. Better than never? I hope so üôè</p>

<h2 class="no_toc" id="overview">Overview</h2>
<ul id="markdown-toc">
  <li><a href="#structural-typing-you-say">Structural typing, you say?</a></li>
  <li><a href="#show-me-yours">Show me yours</a></li>
  <li><a href="#derivelabelledgeneric">[derive(LabelledGeneric)]</a></li>
  <li><a href="#derivelabelledgeneric-1">[derive(LabelledGeneric)]</a></li>
  <li><a href="#derivelabelledgeneric-2">[derive(LabelledGeneric)]</a>    <ul>
      <li><a href="#quick-review-of-labelledgeneric">Quick review of <code>LabelledGeneric</code></a></li>
      <li><a href="#detour-plucking-by-labelled-field">Detour: Plucking by labelled field</a></li>
      <li><a href="#pathtraverser"><code>PathTraverser</code></a></li>
      <li><a href="#path-path-and-path"><code>Path</code>, <code>path!</code> and <code>Path!</code></a>        <ul>
          <li><a href="#value-level">Value-level</a></li>
          <li><a href="#type-level">Type-level</a></li>
        </ul>
      </li>
      <li><a href="#another-example">Another example</a></li>
    </ul>
  </li>
  <li><a href="#derivelabelledgeneric-3">[derive(LabelledGeneric)]</a></li>
  <li><a href="#derivelabelledgeneric-4">[derive(LabelledGeneric)]</a>    <ul>
      <li><a href="#conclusion">Conclusion</a></li>
    </ul>
  </li>
</ul>

<h2 id="structural-typing-you-say">Structural typing, you say?</h2>

<p>‚ÄúStructural typing‚Äù was thrown around up there ‚Üë, but what do we mean? To quote <a href="https://en.wikipedia.org/wiki/Structural_type_system">Wiki</a>:</p>

<blockquote>
  <p>A structural type system (or property-based type system) is a major class of type system in which type compatibility and equivalence are determined by the type‚Äôs actual structure or definition and not by other characteristics such as its name or place of declaration. Structural systems are used to determine if types are equivalent and whether a type is a subtype of another. It contrasts with nominative systems, where comparisons are based on the names of the types or explicit declarations, and duck typing, in which only the part of the structure accessed at runtime is checked for compatibility.</p>
</blockquote>

<p>Out-of-the-box-Rust has <a href="https://en.wikipedia.org/wiki/Nominal_type_system">nominally typed</a> functions <sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> <sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>. For the purposes of this post (and <a href="https://github.com/lloydmeta/frunk">frunk</a>), we specifically mean <code>struct</code>s and their fields when it comes to ‚Äústructure‚Äù<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>, and <strong>not</strong> <a href="https://doc.rust-lang.org/rust-by-example/fn/methods.html">methods</a> that they get from <code>impl</code>s of themselves or <code>trait</code>s. Why? Well, you can‚Äôt spell ‚Äústructural typing without <code>struct</code>, I‚Äôve been mostly focused on <code>struct</code>s, and ‚Ä¶ simplicity üòÇ. Also, to my mind, <code>trait</code>s already enable a kind of part-way ‚Äústructural typing‚Äù of methods <sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup>.</p>

<h2 id="show-me-yours">Show me yours</h2>

<p>I Read Somewhere ‚Ñ¢ that giving a concrete example upfront helps people decide if they want to keep reading (if it aligns with their interests), plus there are lots of movies where the first scene you see is chronologically from the end of the story, followed by a rewinding sound and jump back to the beginning ‚Ä¶ and Hollywood knows engagement. Anyway, we‚Äôll end up with something that allows us to do write this sort of thing:</p>

<p>```rust
/// Function that generically takes any struct <code>A</code> that is traversable with <code>.pet.name</code>, if
/// doing so returns a <code>String</code>
///
/// This is done without declaring any traits specific to this traversal
fn print_pet_name&lt;A, Idx&gt;(obj: A) -&gt; ()
                                 // ‚Üì dot-separated structural path
    where A: PathTraverser&lt;Path!(pet.name), Idx, TargetValue=String&gt;
                                 // ‚Üë üéâ
{
    println!(
        ‚ÄúPet name [{}]‚Äù,
        path!(pet.name).get(obj)
    );
}</p>

<p>// Pass it any object that has <code>pet.name</code>
print_pet_name(dog_person);
print_pet_name(cat_person);
print_pet_name(hamster_person);
print_pet_name(snake_person);
print_pet_name(goldfish_person);
print_pet_name(house);
```</p>

<p>The objects you pass to the <code>print_pet_name</code> function don‚Äôt need to know anything specific to it nor structurally typed functions in general: their struct declarations just need to <code>derive(LabelledGeneric)</code> and have a structure that complies with the function‚Äôs type signature (i.e. have a <code>pet.name</code> path that returns a <code>String</code>):</p>

<p>```rust
#[derive(LabelledGeneric)]
struct Dog {
    name: String,
    age: u32
}</p>

<h1 id="derivelabelledgeneric">[derive(LabelledGeneric)]</h1>
<p>struct Cat {
    name: String,
    age: u32
}</p>

<p>// The next two structs can both be traversed with <code>pet.age</code></p>

<h1 id="derivelabelledgeneric-1">[derive(LabelledGeneric)]</h1>
<p>struct DogPerson {
  name: String,
  pet: Dog
}</p>

<h1 id="derivelabelledgeneric-2">[derive(LabelledGeneric)]</h1>
<p>struct CatPerson {
  name: String,
  pet: Cat
}</p>

<p>// etc etc</p>

<p>let dog = Dog {
    name: ‚ÄúOdie‚Äù.to_string(),
    age: 32
};</p>

<p>let cat = Cat {
    name: ‚ÄúGarfield‚Äù.to_string(),
    age: 16
};</p>

<p>let dog_person = DogPerson {
  name: ‚ÄúJon‚Äù.to_string(),
  pet: dog
};</p>

<p>let cat_person = CatPerson {
  name: ‚ÄúJon‚Äù.to_string(),
  pet: cat
};
```</p>

<p>That‚Äôs it. The API is relatively clean, simple to write, read, and understand (IMO), and there are no <code>unsafe</code> or <code>dyn</code> traits anywhere (even in the implementation). And, you can still declare and treat your <code>struct</code>s as you normally would, passing them to nominally typed functions, implementing <code>trait</code>s as you normally would etc.</p>

<p>Still, when used with structurally typed functions like <code>print_pet_name</code>, the compiler will as usual ensure that:</p>

<ol>
  <li>The paths accessed on the generic parameter <code>A</code> inside the structurally typed function are constrained by the function‚Äôs type signature.</li>
  <li>The <code>LabelledGeneric</code> objects passed as arguments to the structurally typed function support the required path in the function‚Äôs type signature.</li>
</ol>

<p>The functions themselves are not constrained to just <em>getting</em> values, they can also <em>set</em> values too (see the <a href="#another-example">other example at the end of the post</a>)</p>

<h2 id="quick-review-of-labelledgeneric">Quick review of <code>LabelledGeneric</code></h2>

<p>By adding a <code>#[derive(LabelledGeneric)]</code> attribute to a struct, like so:</p>

<p><code>rust
#[derive(LabelledGeneric)]
struct Dog {
    name: String,
    age: u32
}
</code></p>

<p>we gain the ability to turn a <code>Dog</code> object into a labelled heterogenous list:</p>

<p><code>rust
let dog = Dog {
    name: "Odie".to_string(),
    age: 32
};
let as_labelled = &lt;Dog as LabelledGeneric&gt;::into(dog);
let expected_labelled = hlist![
    // in reality the field label is a tuple of type-level chars, but ignore that for now
    field!(name, "Odie".to_string()),
    field!(age, 32)
];
assert_eq!(expected_labelled, as_labelled);
</code></p>

<p>This ability to turn a <code>struct</code> into a heterogenous List of ‚Äúfields‚Äù (type-level labels and values, henceforth ‚Äúlabelled HList‚Äù) paves the way for us to go from nominative typing  (does this type have the right name?) to structural typing (does this type have a given structure?).</p>

<p>For a more thorough review of HLists and <code>LabelledGeneric</code>, see <a href="/blog/2017/03/04/labelledgeneric-in-rust-what-why-how/">this post</a>.</p>

<h2 id="detour-plucking-by-labelled-field">Detour: Plucking by labelled field</h2>

<p>Given a labelled HList, it would be useful to be able to ‚Äúpluck‚Äù a value out of it by using a type-level field name. That would allow us to have compile-time-checked access of a field in a labelled Hlist by type-level name:</p>

<p><code>rust
// Following from the above `Dog` example
let (age_field, _): (Field&lt;age, _&gt;, _) = as_labelled.pluck_by_name();
assert_eq!(32, age_field.value);
</code></p>

<p>This is the equivalent of accessing a specific <code>.age</code> field on a <code>Dog</code> struct in the normal Rust Way ‚Ñ¢, but we‚Äôre doing it our own way on its labelled HList equivalent, using user-declared types and taking advantage of the type system.</p>

<p>The trait would look like this:</p>

<p>```rust
pub trait ByNameFieldPlucker&lt;TargetKey, Index&gt; {
    type TargetValue;
    type Remainder;</p>

<pre><code>/// Returns a pair consisting of the value pointed to by the target key and the remainder.
fn pluck_by_name(self) -&gt; (Field&lt;TargetKey, Self::TargetValue&gt;, Self::Remainder); } ```
</code></pre>

<p>The implementation of this ‚Äúby-name-field‚Äù Plucker shares much with the normal <code>Plucker</code> mentioned in the previous post, so instead of re-explaining things like the <code>Index</code> type param, I‚Äôll simply add <a href="https://beachape.com/blog/2017/03/12/gentle-intro-to-type-level-recursion-in-Rust-from-zero-to-frunk-hlist-sculpting/#plucking-from-hlists">a link to that section</a> and show the implementation for the exit and recursion implementations here:</p>

<p>```rust
/// Implementation when the pluck target key is in the head.
impl&lt;K, V, Tail&gt; ByNameFieldPlucker&lt;K, Here&gt; for HCons&lt;Field&lt;K, V&gt;, Tail&gt; {
    type TargetValue = V;
    type Remainder = Tail;</p>

<pre><code>#[inline(always)]
fn pluck_by_name(self) -&gt; (Field&lt;K, Self::TargetValue&gt;, Self::Remainder) {
    let field = field_with_name(self.head.name, self.head.value);
    (field, self.tail)
} }
</code></pre>

<p>/// Implementation when the pluck target key is in the tail.
impl&lt;Head, Tail, K, TailIndex&gt; ByNameFieldPlucker&lt;K, There<tailindex>&gt; for HCons&lt;Head, Tail&gt;
where
    Tail: ByNameFieldPlucker&lt;K, TailIndex&gt;,
{
    type TargetValue = &lt;Tail as ByNameFieldPlucker&lt;K, TailIndex&gt;&gt;::TargetValue;
    type Remainder = HCons&lt;Head, &lt;Tail as ByNameFieldPlucker&lt;K, TailIndex&gt;&gt;::Remainder&gt;;</tailindex></p>

<pre><code>#[inline(always)]
fn pluck_by_name(self) -&gt; (Field&lt;K, Self::TargetValue&gt;, Self::Remainder) {
    let (target, tail_remainder) =
        &lt;Tail as ByNameFieldPlucker&lt;K, TailIndex&gt;&gt;::pluck_by_name(self.tail);
    (
        target,
        HCons {
            head: self.head,
            tail: tail_remainder,
        },
    )
} } ```
</code></pre>

<p>In truth, it probably makes sense to re-write the <code>ByNameFieldPlucker</code> implementation(s) in terms of <code>Plucker</code>, but this felt somewhat more straightforward when I wrote it at the time for <code>transmogrify</code>ing.</p>

<h2 id="pathtraverser"><code>PathTraverser</code></h2>

<p><code>ByNameFieldPlucker</code> provides us with a way of accessing <em>a</em> field on <em>single</em> struct, but we want to be able to traverse multiple levels of structs. For instance, given the aformentioned <code>Dog</code> and <code>DogPerson</code> structs, Rust allows us to get the age of his dog by doing <code>dog_person.pet.age</code>, and we‚Äôd like to be able to do that structurally. Enter <code>PathTraverser</code>:</p>

<p>```rust
pub trait PathTraverser&lt;Path, Indices&gt; {
    type TargetValue;</p>

<pre><code>/// Returns a pair consisting of the value pointed to by the target key and the remainder.
fn get(self) -&gt; Self::TargetValue; } ```
</code></pre>

<p>Instead of <code>Index</code>, its second type param is <code>Indices</code> to reflect the fact that we‚Äôre going to need multiple <code>Index</code>s to ‚Äúpluck‚Äù by field name from. The ‚Äúexit‚Äù (the last, aka no-more-dots, target field name and value type are on the current struct) and ‚Äúrecurse‚Äù (the last target field name and value type are in an ‚Äúinner‚Äù struct) implementations of this trait are as follows:</p>

<p>```rust
// For the case where we have no more field names to traverse
impl&lt;Name, PluckIndex, Traversable&gt; PathTraverser&lt;Path&lt;HCons&lt;Name, HNil¬ª, PluckIndex&gt;
    for Traversable
where
    Traversable: IntoLabelledGeneric,
    <traversable as="" intolabelledgeneric="">::Repr: ByNameFieldPlucker&lt;Name, PluckIndex&gt;,
{
    type TargetValue = &lt;<traversable as="" intolabelledgeneric="">::Repr as ByNameFieldPlucker&lt;
        Name,
        PluckIndex,
    &gt;&gt;::TargetValue;</traversable></traversable></p>

<pre><code>#[inline(always)]
fn get(self) -&gt; Self::TargetValue {
    self.into().pluck_by_name().0.value
} }
</code></pre>

<p>// For the case where a path nests another path (e.g. nested traverse)
impl&lt;HeadName, TailNames, HeadPluckIndex, TailPluckIndices, Traversable&gt;
    PathTraverser&lt;Path&lt;HCons&lt;HeadName, Path<tailnames>&gt;&gt;, HCons&lt;HeadPluckIndex, TailPluckIndices&gt;&gt;
    for Traversable
where
    Traversable: IntoLabelledGeneric,
    <traversable as="" intolabelledgeneric="">::Repr: ByNameFieldPlucker&lt;HeadName, HeadPluckIndex&gt;,
    &lt;<traversable as="" intolabelledgeneric="">::Repr as ByNameFieldPlucker&lt;HeadName, HeadPluckIndex&gt;&gt;::TargetValue:
        PathTraverser&lt;Path<tailnames>, TailPluckIndices&gt;,
{
    type TargetValue = &lt;&lt;<traversable as="" intolabelledgeneric="">::Repr as ByNameFieldPlucker&lt;HeadName, HeadPluckIndex&gt;&gt;::TargetValue as
    PathTraverser&lt;Path<tailnames>, TailPluckIndices&gt;&gt;::TargetValue ;</tailnames></traversable></tailnames></traversable></traversable></tailnames></p>

<pre><code>#[inline(always)]
fn get(self) -&gt; Self::TargetValue {
    self.into().pluck_by_name().0.value.get()
} } ```
</code></pre>

<p>That type signature is a bit hairy.</p>

<p>It‚Äôs a bit ‚ÄúInceptiony‚Äù to think about what the <code>Indices</code> type param might look like at a given callsite, and for the most part it doesn‚Äôt matter for users (we make it the compiler‚Äôs job to fill it in or error out trying), but for the purposes of trying to understand what‚Äôs going on, it‚Äôs reasonable to imagine this as the <code>Indices</code> for structurally accessing <code>dog_person.pet.age</code>:</p>

<p><code>rust
HList![
  &lt;There&lt;Here&gt;&gt;, // First access is `.pet`, which is the 2nd field on `DogUser`
  &lt;There&lt;Here&gt;&gt;, // First access is `.age`, which is the 2nd field on `Dog`
]
</code></p>

<h2 id="path-path-and-path"><code>Path</code>, <code>path!</code> and <code>Path!</code></h2>

<p>The last piece we need is something that allows us to describe a path (e.g. <code>pet.age</code>). Since the path is going to be itself a type-level thing (reminder: we pluck values by type-level field name), we can model this as a newtype wrapper around the zero-sized <a href="https://doc.rust-lang.org/std/marker/struct.PhantomData.html"><code>PhantomData&lt;T&gt;</code> type</a></p>

<p>```rust
pub struct Path<t>(PhantomData<t>);</t></t></p>

<p>impl<t> Path<t> {
    /// Creates a new Path
    pub fn new() -&gt; Path<t> {
        Path(PhantomData)
    }</t></t></t></p>

<pre><code>/// Gets something using the current path
pub fn get&lt;V, I, O&gt;(&amp;self, o: O) -&gt; V
where
    O: PathTraverser&lt;Self, I, TargetValue = V&gt;,
{
    o.get()
} } ```
</code></pre>

<p><code>Path</code>s basically works like ‚Äúlens‚Äù, only without the target type locked down (maybe that will be a future type in frunk‚Ä¶), enabling this sort of thing:</p>

<p>```rust
let p = path!(pet.name);</p>

<p>let dog_age: &amp;u32 = p.get(&amp;dog_person);
let cat_age: &amp;u32 = p.get(&amp;cat_person);
```</p>

<p>That‚Äôs all fine and good. From here on though, things get a bit tricky because we need to create friendly ways to declare <code>Path</code>s, and <code>T</code> needs to be a type level path, one that needs to be <strong>easy</strong> to use <em>and</em> <strong>compatible</strong> with the way <a href="https://beachape.com/blog/2017/03/04/labelledgeneric-in-rust-what-why-how/#type-level-characters-and-strings"><code>LabelledGeneric</code> encodes field names into type-level strings</a>. Rubber, meet road.</p>

<p>To make declaring value and type level <code>Path</code>s easy to use, we‚Äôll need to make use of procedural macros because they allow us to take user-defined expressions and turn them into type-level paths made of type-level field names, and doing so with <a href="https://doc.rust-lang.org/book/ch19-06-macros.html#declarative-macros-with-macro_rules-for-general-metaprogramming">declarative macros</a> is extremely difficult (I gave it a stab) if not impossible.</p>

<p>A core function that is reused for generating value-level <strong>and</strong> type-value <code>Path</code>s is:</p>

<p><code>rust
fn build_path_type(path_expr: Expr) -&gt; impl ToTokens {
    let idents = find_idents_in_expr(path_expr);
    idents
        .iter()
        .map(|i| build_label_type(i))
        .fold(quote!(::frunk_core::hlist::HNil), |acc, t| {
            quote! {
            ::frunk_core::path::Path&lt;
                ::frunk_core::hlist::HCons&lt;
                   #t,
                   #acc
                &gt;
              &gt;
            }
        })
}
</code></p>

<p>Where <code>find_idents_in_expr</code> is a <a href="https://github.com/lloydmeta/frunk/blob/8eb9ccb08f9060c4aa008a4f1786bc441c97ee27/proc-macro-helpers/src/lib.rs#L193-L220">function</a> turns a path expression like <code>pet.age</code> into a vector of <a href="https://doc.rust-lang.org/proc_macro/struct.Ident.html"><code>Ident</code> identifiers</a>.</p>

<p>We then pass those through to the <a href="https://github.com/lloydmeta/frunk/blob/8eb9ccb08f9060c4aa008a4f1786bc441c97ee27/proc-macro-helpers/src/lib.rs#L131-L146"><code>build_label_type</code> function</a>, which translates each <code>Ident</code> into a type-level name. This is also re-used by <code>LabelledGeneric</code>‚Äôs derivation macro, which is important because it ensures that the way field names are encoded as types for <code>Path</code>s is compatible with the way field names are encoded as types in <code>LabelledGeneric</code>-produced labelled HLists.</p>

<h3 id="value-level">Value-level</h3>

<p>The macro for creating a <code>Path</code> <em>value</em> simply instantiates a <code>Path</code>  using <code>Path::new()</code>, but with a type ascription based on what gets returned from <code>build_path_type</code>.</p>

<p><code>rust
pub fn path(input: TokenStream) -&gt; TokenStream {
    let expr = parse_macro_input!(input as Expr);
    let path_type = build_path_type(expr);
    let ast = quote! {
        {
            let p: #path_type = ::frunk_core::path::Path::new();
            p
        }
    };
    //    println!("ast: [{}]", ast);
    TokenStream::from(ast)
}
</code></p>

<h3 id="type-level">Type-level</h3>

<p>The macro for creating a <code>Path</code> <em>type</em> simply splices the type returned from <code>build_path_type</code>.</p>

<p><code>rust
pub fn Path(input: TokenStream) -&gt; TokenStream {
    let expr = parse_macro_input!(input as Expr);
    let path_type = build_path_type(expr);
    let ast = quote! {
        #path_type
    };
    //    println!("ast: [{}]", ast);
    TokenStream::from(ast)
}
</code></p>

<h2 id="another-example">Another example</h2>

<p>Getting and setting ids of from <code>struct</code>s, without declaring a <code>GetId</code> or <code>SetId</code> trait and implementing it for each type:</p>

<p>```rust
#[derive(LabelledGeneric)]
struct User {
    id: String,
    is_admin: bool,
}</p>

<h1 id="derivelabelledgeneric-3">[derive(LabelledGeneric)]</h1>
<p>struct Book {
    id: String,
    title: String,
}</p>

<h1 id="derivelabelledgeneric-4">[derive(LabelledGeneric)]</h1>
<p>struct Store {
    id: String,
    address: String,
}</p>

<p>// Object references passed to this function just need to have an <code>id: String</code>
// in their struct defintion.
fn get_id&lt;‚Äôa, A, Idx&gt;(obj: &amp;‚Äôa A) -&gt; &amp;‚Äôa str
where
    &amp;‚Äôa A: PathTraverser&lt;Path!(id), Idx, TargetValue = &amp;‚Äôa String&gt;,
{
    path!(id).get(obj).as_str()
}</p>

<p>// DRYed-out setter
fn set_id&lt;‚Äôa, A, Idx&gt;(obj: &amp;‚Äôa mut A, set_to: String) -&gt; ()
where
    &amp;‚Äôa mut A: PathTraverser&lt;Path!(id), Idx, TargetValue = &amp;‚Äôa mut String&gt;,
{
    *path!(id).get(obj) = set_to;
}</p>

<p>let mut user = User {
    id: ‚Äúuser_id‚Äù.to_string(),
    is_admin: true,
};
let mut book = Book {
    id: ‚Äúbook_id‚Äù.to_string(),
    title: ‚ÄúTale of Three structs‚Äù.to_string(),
};
let mut store = Store {
    id: ‚Äústore_id‚Äù.to_string(),
    address: ‚ÄúSesame street‚Äù.to_string(),
};</p>

<p>println!(‚Äú{}‚Äù, get_id(&amp;user));
println!(‚Äú{}‚Äù, get_id(&amp;book));
println!(‚Äú{}‚Äù, get_id(&amp;store));</p>

<p>// ‚Üë Prints:
//
// user_id
// book_id
// store_id</p>

<p>set_id(&amp;mut user, ‚Äúnew_user_id‚Äù.to_string());
set_id(&amp;mut book, ‚Äúnew_book_id‚Äù.to_string());
set_id(&amp;mut store, ‚Äúnew_store_id‚Äù.to_string());</p>

<p>// Print again
println!(‚Äú{}‚Äù, get_id(&amp;user));
println!(‚Äú{}‚Äù, get_id(&amp;book));
println!(‚Äú{}‚Äù, get_id(&amp;store));</p>

<p>// ‚Üë Prints:
//
// new_user_id
// new_book_id
// new_store_id
```</p>

<h2 id="conclusion">Conclusion</h2>

<p>The <code>PathTraverser</code> trait and <code>Path</code> type build on <code>LabelledGeneric</code> and <code>HList</code> as core abstractions, which is nice because we get some more mileage out of them, and it means that there are no additional traits that you need to import nor implement (even as a macro).</p>

<p>As usual, it‚Äôs compile-time checked, but it‚Äôs also <strong>performant</strong>. In <a href="https://beachape.com/frunk/dev/bench/">benchmarks</a>, tests comparing <code>lens_path*</code> (structurally typed traversal) versus <code>normal_path*</code> (Rust lang built-in traversal) traversals show that they perform the same: in other words, using structural typing in this way adds zero overhead.</p>

<p>As usual, please give it a spin and chime in with any questions, corrections, and suggestions !</p>

<h4 class="no_toc" id="footnotes">Footnotes</h4>

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>Technically, everything for writing basic structurally typed functions minus support for jumping through <code>.</code>-separated fields was available in frunk since <a href="https://github.com/lloydmeta/frunk/pull/124/files#diff-1dbf59e47bd20977b2b93de89dc0b1ca339be36509288a64602c2e33be4f7e25R552">October of 2018</a> at the latest because <code>ByNamePlucker</code> was available already by then.<a href="#fnref:1" rel="reference">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>In Rust, macros can and have been used to approximate structural typing (macro arguments aren‚Äôt typed, so you can just do something like <code>$x.access.some.path</code> and have the compiler expand and fail it if an object at the callsite doesn‚Äôt have that path). This is fine too, but macros can be hard to read and maintain (they have no type signature, so you‚Äôll need to look in the implementation/docs to know what it expects), and they <a href="https://doc.rust-lang.org/book/ch19-06-macros.html#the-difference-between-macros-and-functions">aren‚Äôt functions</a>; they‚Äôre code that write code. Again, The Macro Way is Fine ‚Ñ¢; this post just offers an alternative.<a href="#fnref:2" rel="reference">&#8617;</a></p>
    </li>
    <li id="fn:3">
      <p>Rust <em>did</em> at one point have built-in support structural records, but <a href="https://github.com/rust-lang/rust/issues/3089">it was removed almost 9 years ago before 1.0 was released</a>. I found an <a href="https://internals.rust-lang.org/t/why-were-structural-records-removed/1553/2">answer to a question on the internal Rust lang forum</a> asking why, and the 3 reasons listed for removal at the time made sense; the <code>Path</code> implementation described here (and implemented in <a href="https://github.com/lloydmeta/frunk">frunk</a>) addresses 1, if not 2, of the 3 issues (field order requirement and recursion IIUC), leaving the issue of field visibility, which I believe can probably be addressed as an option to the <code>LabelledGeneric</code> derive.<a href="#fnref:3" rel="reference">&#8617;</a></p>
    </li>
    <li id="fn:4">
      <p>There are some who would call this ‚Äúrow polymorphism‚Äù, which is maybe (more) correct, but it‚Äôs also a term that is much more niche (pronounced: ‚Äúless generally known‚Äù or ‚Äúless searched for‚Äù). Indeed, depending on whom you ask, ‚Äúrow polymorphism‚Äù is regarded as being under the ‚Äústructural typing‚Äù umbrella (<a href="https://www.cs.cmu.edu/~aldrich/courses/819/slides/rows.pdf">1</a>, <a href="https://journal.infinitenegativeutility.com/structural-types-and-duck-typing">2</a>), but in any case, I personally find the distinction to be of questionable value in the context of Rust ü§∑‚Äç‚ôÇÔ∏è. Having said that, feel free to substitute ‚Äúrow polymorphism‚Äù in place of ‚Äústructural typing‚Äù when reading this post if it helps you slog through the actual important bits :)<a href="#fnref:4" rel="reference">&#8617;</a></p>
    </li>
    <li id="fn:5">
      <p><code>trait</code>s can be adhoc and auto-implemented, and directly used as constraints in functions (though still nominally), so being structurally-typed on <code>trait</code>s feels a bit less of a problem that needs solving, and I get the feeling that it will be even less so with things like <a href="https://rust-lang.github.io/rfcs/1210-impl-specialization.html">specialization</a> coming down the pipeline, which will allow for more blanket and overlapping <code>impl</code>s.<a href="#fnref:5" rel="reference">&#8617;</a></p>
    </li>
  </ol>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rust: A Scala Engineer's Perspective]]></title>
    <link href="https://beachape.com/blog/2017/05/24/rust-from-scala/"/>
    <updated>2017-05-24T13:45:00+00:00</updated>
    <id>https://beachape.com/blog/2017/05/24/rust-from-scala</id>
    <content type="html"><![CDATA[<p>The 1st year anniversary of my first line of Rust code is coming up, and it‚Äôs getting for 5 years since I wrote my first line of Scala code. I thought it would be a good idea to summarise my Scala-tinted perspective of The Rust Experience <sup>TM</sup>, one year on.</p>

<p><span class='caption-wrapper center' style='width: 468px'><img class='caption' src='/images/rusty-spiral-staircase.jpg' width='450' height='450'><span class='caption-text'><a href="https://www.flickr.com/photos/janodecesare/2947948666/in/photolist-5uv1r9-56xXaX-4bDqR-SebcMQ-maN4i-7N23dr-7xSH4D-7rhtiD-pHDnby-62icy-pZNZN8-6cZ79B-5uv1BG-4cTa1X-Bwg7kq-7ahJE2-pb2Mcq-5DQf7p-o2NMu4-3VwpKy-nKqFJu-nJCpHS-aA3uj1-zi3AJf-9iUi3a-maMRE-maMUM-maMSb-5bpZDr-388hw8-maMSL-maN4Q-68jZPS-dWFLCF-aA3urd-4vjtb6-7B76ht-36fhwZ-maMYH-7jPJw9-avc8L2-4SQCD3-4C4njx-h46Ev-maN5y-DuqqVb-CpMJiF-maMY4-maN7f-Raj8Es">Rusty spiral staircase</a> by Jano De Cesare</span></span></p>

<p>This is <em>not</em> an objective language vs language comparison. I‚Äôve written this post as part experience dump, part waymark for other Scala devs who are exploring or thinking of exploring Rust.</p>

<!-- more -->

<h2 class="no_toc" id="a-bit-about-me">A bit about me</h2>

<p>I‚Äôve written <a href="https://github.com/lloydmeta?utf8=%E2%9C%93&amp;tab=repositories&amp;q=&amp;type=&amp;language=rust">a few Rust libraries/tools</a> as well as <a href="https://github.com/lloydmeta?utf8=%E2%9C%93&amp;tab=repositories&amp;q=&amp;type=&amp;language=scala">Scala ones</a>. For all intents and purposes, I‚Äôm a Scala engineer: I get paid to do it and it‚Äôs by far my strongest language. I‚Äôve used Rust in a few of my side projects (libraries and smaller utilities).</p>

<p>On the Scala side, I‚Äôm the author of <a href="https://github.com/lloydmeta/enumeratum">enumeratum</a>, which brings flexible enums and <a href="https://github.com/lloydmeta/enumeratum#valueenum">value-enums</a> to Scala as a library. I‚Äôve also dabbled in writing macro-based libraries to make things like <a href="https://github.com/lloydmeta/freast">Free Monads</a> and <a href="https://github.com/lloydmeta/diesel">Tagless Final</a> nicer to use.</p>

<p>On the Rust side, I‚Äôve written <a href="https://github.com/lloydmeta/frunk">frunk</a>, a Rust functional programming toolbelt that is roughly a port of <a href="https://github.com/milessabin/shapeless">Shapeless</a> with a bit of <a href="https://github.com/typelevel/cats">cats</a>/<a href="https://github.com/scalaz/scalaz">scalaz</a> mixed in, which does some pretty funky things with the type system that I‚Äôve blogged about (<a href="/blog/2017/03/04/labelledgeneric-in-rust-what-why-how/">1</a>, <a href="/blog/2017/03/12/gentle-intro-to-type-level-recursion-in-Rust-from-zero-to-frunk-hlist-sculpting/">2</a>, <a href="/blog/2017/04/12/boilerplate-free-struct-transforms-in-rust/">3</a>, <a href="/blog/2017/02/04/rust-generic-not-generics/">4</a>). I also wrote a Rust port of <a href="https://requestb.in">requestb.in</a> called <a href="https://github.com/lloydmeta/rusqbin">rusqbin</a> based on Hyper, and a small WIP async client for Microsoft Cognitive services called <a href="https://github.com/lloydmeta/cogs">cogs</a>.</p>

<h3 class="no_toc" id="forewarning">Forewarning</h3>

<ul>
  <li>I‚Äôm biased towards Scala and I‚Äôve mostly gotten used to <a href="http://www.lihaoyi.com/post/WartsoftheScalaProgrammingLanguage.html">Scala‚Äôs warts</a>. That said, I make an effort to try to be as neutral as possible.</li>
  <li>When I talk about Rust, I mean Rust stable. This is because I only use Scala stable.</li>
  <li>Some of the stuff that I write about with regards to Rust might have changed by the time you read this. After all, there is an ongoing <a href="https://blog.rust-lang.org/2017/03/02/lang-ergonomics.html">ergonomics initiative</a></li>
</ul>

<h2 class="no_toc" id="overview">Overview</h2>
<ul id="markdown-toc">
  <li><a href="#things-im-happy-with">Things I‚Äôm happy with</a>    <ul>
      <li><a href="#batteries-included">Batteries included</a></li>
      <li><a href="#type-system">Type System</a></li>
      <li><a href="#macros">Macros</a></li>
      <li><a href="#compile-time-optimisations">Compile-time optimisations</a></li>
      <li><a href="#syntax">Syntax</a></li>
      <li><a href="#interoperability-with-c">Interoperability with C</a></li>
      <li><a href="#the-current-zeitgeist">The current Zeitgeist</a></li>
    </ul>
  </li>
  <li><a href="#things-ive-adjusted-to">Things I‚Äôve adjusted to</a>    <ul>
      <li><a href="#semicolons">Semicolons</a></li>
      <li><a href="#ownership-model-stack-vs-heap">Ownership model: Stack vs heap</a></li>
    </ul>
  </li>
  <li><a href="#things-i-wish-were-different">Things I wish were different</a>    <ul>
      <li><a href="#async-io">Async IO</a></li>
      <li><a href="#strings">Strings</a></li>
      <li><a href="#cross-compiling">Cross compiling</a></li>
      <li><a href="#odd-headscratchers">Odd headscratchers</a></li>
      <li><a href="#gimme">Gimme</a></li>
    </ul>
  </li>
  <li><a href="#conclusion">Conclusion</a></li>
</ul>

<h2 id="things-im-happy-with">Things I‚Äôm happy with</h2>

<h3 id="batteries-included">Batteries included</h3>

<p>The dev-environment-setup experience with Rust is amazing. The Rust community has striven to make it super easy to <a href="https://doc.rust-lang.org/book/getting-started.html">get started with Rust</a> and it shows. Literally <a href="https://doc.rust-lang.org/book/getting-started.html#installing-rust">one shell command</a> will set everything you need up.</p>

<ul>
  <li><code>rustup</code> for managing your Rust toolbelts (different versions/channels of Rust)</li>
  <li><code>cargo</code> for managing your build and for publishing to crates.io, which includes, among other things:
    <ul>
      <li>A <a href="https://doc.rust-lang.org/book/testing.html"><code>test</code> subcommand</a> for running tests</li>
      <li>A <a href="https://doc.rust-lang.org/book/benchmark-tests.html"><code>bench</code> subcommand</a> for running benchmarks</li>
    </ul>
  </li>
  <li><code>rustfmt</code> for formatting your code (runs on cargo projects via <code>cargo fmt</code>)</li>
  <li><code>rustdoc</code> for generating beautiful <a href="https://api.rocket.rs/rocket/">documentation websites</a>.
    <ul>
      <li>This tool supports doc tests with zero additional configuration/setup (runs as part of <code>cargo test</code>)</li>
    </ul>
  </li>
</ul>

<p>Coming from Scala, having all of this set up with no fuss right out of the gate is a breath of fresh air and feels like a big win for productivity. I know there are reasons for Scala‚Äôs more <em>modular</em> approach, but I think it would be nice if <em>some</em> of this rubbed off on <del>Scala</del> other languages.</p>

<h4 class="no_toc" id="editoride"><strong>Editor/IDE</strong></h4>

<p>When I first started with Rust, I used IntelliJ and its Rust plugin, but later switched to <a href="https://code.visualstudio.com/">Microsoft Studio Code</a> with the <a href="https://github.com/editor-rs/vscode-rust">Rust plugin</a>, which interfaces very well with Rust Language Server (installable as a <a href="https://github.com/rust-lang-nursery/rls#step-3-install-the-rls">rustup toolchain component</a>). It feels very lightweight, and offers all the assistance I need.</p>

<h3 id="type-system">Type System</h3>

<p>If you lean more towards the functional programming paradigm side of Scala then you‚Äôll probably love the following about Rust‚Äôs type system:</p>

<ul>
  <li>No inheritance for data types (there is a bottom type but it‚Äôs used much more sparingly)</li>
  <li>No universal equality</li>
  <li>No nulls</li>
  <li>Traits are basically Haskell typeclasses</li>
  <li>Many more primary types (instead of just <code>Int</code>, there are <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>isize</code>, as well as <code>u8</code>, <code>u16</code> ‚Ä¶ )</li>
</ul>

<p>Essentially Rust has a <em>lot</em> of the good things about Scala‚Äôs type system. One thing currently missing from Rust is first class support for higher-kinded types (HKT), which, to be honest, I don‚Äôt miss too much because:</p>

<ol>
  <li>There are ways to emulate it to an extent</li>
  <li>Rust‚Äôs ownership/memory model tends to push you towards thinking more granularly about your values/references, something which is perhaps in conflict with the kind of programming typically involving HKT-based abstractions.</li>
</ol>

<p>If this still sounds unacceptable, just know that you can get quite far in building reuseable abstractions using Rust‚Äôs traits + associated types, and BurnSushi‚Äôs <a href="https://github.com/BurntSushi/quickcheck">port of quickcheck</a> is available for writing and enforcing laws.</p>

<p>There are a few interesting things in the pipeline as well:</p>

<ol>
  <li><a href="https://github.com/rust-lang/rfcs/issues/324">Higher kinded polymorphism</a></li>
  <li><a href="https://github.com/rust-lang/rfcs/issues/1930">Pi (value) types</a></li>
</ol>

<p>Adding functionality by using Rust‚Äôs traits should be familiar territory if you‚Äôve written typeclass-like stuff in Scala. In fact, Rust‚Äôs trait system feels a lot more similar to Haskell‚Äôs typeclass system than Scala‚Äôs, something which has its pros and cons (no scoping of implementations for a given type, for example). I‚Äôve written an intro/guide to Rust‚Äôs trait system in <a href="/blog/2017/03/12/gentle-intro-to-type-level-recursion-in-Rust-from-zero-to-frunk-hlist-sculpting/">another post</a>.</p>

<h4 class="no_toc" id="type-inference"><strong>Type inference</strong></h4>

<p>Both Rust and Scala have local type inference, and overall, they work in pretty much the same way. In both of them, you need to write the types for your function parameters. In Scala, you can leave the return type off and have the compiler infer it for you, in Rust you can‚Äôt (if you leave it off, it is assumed to be <code>()</code>, unit).</p>

<h3 id="macros">Macros</h3>

<p>The <a href="https://doc.rust-lang.org/book/macros.html">Rust macro system</a>, while less powerful than Scala‚Äôs, is quite useful for keeping your code DRY and importantly, integrates really well with the rest of the language. It is in fact enabled and available out of the box without any additional dependencies/flags.</p>

<p>Compared with Scala‚Äôs macros, Rust‚Äôs macros feel like a very natural part of the language, and you‚Äôll run into them quite often when reading/using Rust libraries. In Rust code bases, you‚Äôll often see macros declared and used immediately for the purpose of code generation (e.g. deriving trait implementations for a list of numeric types, or for tuples up to N elements), something that Scala users have generally done ‚Äúout-of-band‚Äù by <a href="http://www.scala-sbt.org/0.13/docs/Howto-Generating-Files.html">hooking into SBT</a> and using another templating or AST-based tool.</p>

<p>On the other hand, in Scala, the usual refrain is ‚Äúdon‚Äôt write macros if you don‚Äôt have to‚Äù. When I compare the approaches the two languages have taken, I feel that Scala may have been overambitious in terms of giving developers power, thus leading to deprecations of APIs that can‚Äôt be maintained due to complexity. Indeed, Scala‚Äôs metaprogramming toolkit is going through another reform with the migration to <a href="http://scalameta.org/">Scalameta</a>.</p>

<p>Because of its simplicity (the macros work based on a series of patterns), Rust‚Äôs macro API may feel limiting at first, but if you stick with it, you‚Äôll likely find that you can accomplish more than what you initially thought. For example, the fact that you can build/restructure macro arguments recursively (!) and call the macro again (or even call another macro) is <a href="https://stackoverflow.com/a/40070907/1814775">a fairly powerful tool</a>.</p>

<p>Having said that, in addition to the legacy macro system, Rust will soon be getting <a href="https://github.com/rust-lang/rfcs/blob/master/text/1566-proc-macros.md">procedural macros</a>, which are more similar to what Scala devs are used to seeing. You can get a peek of what procedural macros are like by looking at <a href="https://doc.rust-lang.org/book/procedural-macros.html">custom derives</a>, which I‚Äôve used to implement <a href="/blog/2017/03/04/labelledgeneric-in-rust-what-why-how/"><code>derive</code> for <code>LabelledGeneric</code> in Rust</a>.</p>

<h3 id="compile-time-optimisations">Compile-time optimisations</h3>

<p>I think it‚Äôs not news to anyone that Rust is fast and efficient. The <a href="https://www.rust-lang.org">home page of the official site</a> says it runs ‚Äúblazingly fast‚Äù and features ‚Äúzero-cost abstractions‚Äù, and the Rust-faithfuls loudly trumpted <a href="https://www.reddit.com/r/rust/comments/5vcrvb/rust_is_now_the_fastest_language_on_knucleotide/">Rust‚Äôs defeat of GCC-C in in k-nucleotide</a> a few months ago. Even if you don‚Äôt completely buy into the ‚Äúfaster than C‚Äù part,  it‚Äôs not a big jump to say that Rust performance is in the same ballpark as C, or at least, there is no reason for it not to be (yes, language and implementation are different, compilers make a difference, etc.).</p>

<p>I‚Äôm particularly impressed by the Rust compiler‚Äôs (though I‚Äôm not sure if it‚Äôs LLVM?) ability to compile abstractions away so that the operations they enable have zero overhead. As a personal anecdote, when I wrote <a href="https://github.com/lloydmeta/frunk#labelledgeneric">LabelledGeneric in frunk</a>, I expected there to be <em>some</em> performance difference between using that abstraction for conversions between structs versus writing the conversions by hand (using <code>From</code>). After all, there are non-negligible differences in the Shapeless version of it in Scala land (<a href="https://github.com/lloydmeta/caseclass-conversion-benches#results">benchmark code</a>):</p>

<p>```
// JMH benchmark results</p>

<p>[info] Benchmark                               Mode  Cnt     Score     Error  Units
[info] Benchmarks.from24FieldsManual           avgt   30    33.626 ¬±   1.032  ns/op
[info] Benchmarks.from24FieldsShapeless        avgt   30  4443.018 ¬± 101.612  ns/op
[info] Benchmarks.from25FieldsManual           avgt   30    33.066 ¬±   0.650  ns/op
[info] Benchmarks.from25FieldsShapeless        avgt   30  4859.432 ¬± 104.763  ns/op
```</p>

<p>To my surprise, Rust manages to compile frunk‚Äôs LabelledGeneric-based, non-trivial, multi-step, unoptimised (other than using the stack, no effort was spent) transform between structs into a zero-cost abstraction. That is, using LabelledGeneric for conversion adds <em>zero</em> overhead over writing the transform by hand (<a href="https://github.com/lloydmeta/frunk/blob/master/benches/labelled.rs">benchmark code</a>):</p>

<p>```
// Cargo benchmark results</p>

<p>test from<em>24fields_manual           ‚Ä¶ bench:         109 ns/iter (+/- 49)
test from</em>24fields_labelledgeneric  ‚Ä¶ bench:         104 ns/iter (+/- 24)
test from<em>25fields_manual           ‚Ä¶ bench:         129 ns/iter (+/- 9)
test from</em>25fields_labelledgeneric  ‚Ä¶ bench:         131 ns/iter (+/- 13)
```</p>

<p><img class="center" src="/images/mind-blown.gif" title="‚ÄòMind Blown‚Äô" ></p>

<p><em>Note</em>: The Rust vs Scala <code>LabelledGeneric</code> benchmarks are not completely apples-to-apples (the Rust version needs to instantiate new source objects every run because of move semantics), but they illustrate the performance difference between LabelledGeneric-based vs handwritten conversion in the two languages.</p>

<h3 id="syntax">Syntax</h3>

<p>Overall, the Rust‚Äôs syntax is very similar to Scala‚Äôs. Sure, there are small adjustments here and there (<code>let</code> and <code>let mut</code> vs <code>var</code> and <code>val</code>, you‚Äôll be using angle brackets instead of square ones, etc), but overall the languages feel very similar because they‚Äôre both C-like languages that are heavily inspired by ML.</p>

<p>Scala people will probably rejoice at things like the <a href="https://doc.rust-lang.org/book/enums.html"><code>enum</code></a> being available (coming soon to Scala via Dotty) as well as partial destructuring (e.g. assuming <code>struct Point { x: i32, y: 32}</code>, you can do <code>let Point { x, .. } = p;</code>).</p>

<p>There are a handful of things that you‚Äôll miss just from muscle memory in the beginning, but are either implemented as libraries or are done slightly differently, such as lazy values (<a href="https://github.com/reem/rust-lazy">rust-lazy</a> or <a href="https://github.com/rust-lang-nursery/lazy-static.rs">lazy-static</a>) and methods such as Option‚Äôs <code>foreach</code> (try <code>if let Some(x) = myOption { /* use x here */ }</code> instead). Others are just plain missing, such as by-name parameters (not too big of a deal for me), <code>for</code>/<code>do</code> comprehensions, and keyword arguments (these last two hurt).</p>

<p>Oh, in Rust, types and traits are named the same way as in Scala, in CamelCase, but identifiers (bindings and methods) use snake_case, which I still find makes code look longer but isn‚Äôt a big problem. You‚Äôll find <a href="https://aturon.github.io/style/naming.html">references</a> that can help if you are unsure and you‚Äôll likely pick it up from reading library code anyways.</p>

<p>As with Swift, I haven‚Äôt been able to find conclusive evidence nor credit given to suggest that there was any influence from Scala on Rust ‚Ä¶</p>

<h3 id="interoperability-with-c">Interoperability with C</h3>

<p>Rust makes working with C as smooth as possible while sticking to its mantra of keeping things safe. For reference take a look at the section in the Rust book that deals with <a href="https://doc.rust-lang.org/book/ffi.html">FFI</a>.</p>

<p>```rust
// Taken from the Rust book
#[link(name = ‚Äúsnappy‚Äù)]
extern {
    fn snappy_max_compressed_length(source_length: size_t) -&gt; size_t;
}</p>

<p>let x = unsafe { snappy_max_compressed_length(100) };
```</p>

<p>The syntax might look familiar to those who have played around with <a href="https://scala-native.readthedocs.io/en/latest/">Scala.Native</a>.</p>

<p>```scala
// Taken from Scala Native homepage
@extern object stdlib {
  def malloc(size: CSize): Ptr[Byte] = extern
}</p>

<p>val ptr = stdlib.malloc(32)
```</p>

<p>Since calling C-code can be unsafe (wrt memory, thread-safety), Rust requires you to wrap your C-calls in unsafe. If you wish to hide this from your users, you can wrap these calls in another function.</p>

<p><code>rust
// Taken from the Rust book
pub fn validate_compressed_buffer(src: &amp;[u8]) -&gt; bool {
    unsafe {
        snappy_validate_compressed_buffer(src.as_ptr(), src.len() as size_t) == 0
    }
}
</code></p>

<p>Calling Rust code from C is also <a href="https://doc.rust-lang.org/book/ffi.html#callbacks-from-c-code-to-rust-functions">very smooth</a>, something that Scala Native has yet to implement.</p>

<h3 id="the-current-zeitgeist">The current Zeitgeist</h3>

<p>The current ‚Äúfeel‚Äù of Rust, and its community (or communities, since libraries/frameworks can have their own) is very welcoming and helpful. It‚Äôs also very difficult to quantify so I‚Äôll just list some observations:</p>

<ul>
  <li>Rust stable is only 2 years old and yet there is an official <a href="https://blog.rust-lang.org/2017/03/02/lang-ergonomics.html">ergonomics initiative</a> to reduce friction</li>
  <li>I‚Äôve asked a hand full of questions on StackOverflow and have gotten prompt and helpful answers each time.</li>
  <li>Rust is the #1 ‚Äúmost loved‚Äù language in <a href="https://insights.stackoverflow.com/survey/2016#technology-most-loved-dreaded-and-wanted">StackOverflow‚Äôs 2017 survey</a></li>
  <li>Rust feels very community driven: its got a very lively <a href="https://github.com/rust-lang/rfcs/issues">RFC repo</a> and since I‚Äôve started tinkering in it I‚Äôve seen at least 3 RFCs make it into the language (type macros, custom derives, and <code>?</code> syntax for <code>Try</code>s).</li>
</ul>

<h2 id="things-ive-adjusted-to">Things I‚Äôve adjusted to</h2>

<h3 id="semicolons">Semicolons</h3>

<p>In Scala, semicolons are optional and <em>almost</em> everything is an expression and therefore return values.</p>

<p>```scala
3 // returns 3</p>

<p>val x = 3 // assignment, returns unit</p>

<p>// certain things don‚Äôt return anything though, such as import
// statements, and blocks</p>

<p>import com.beachape._ // returns nothing
object Hello {} // returns nothing
```</p>

<p>In Rust, semicolons are non-optional and <a href="http://rustbyexample.com/expression.html">are of significance</a>. Statements that end with semicolons return <code>()</code> (unit) and those that do not get turned into expressions and thus return a value.</p>

<p>```rust
// taken from the Rust book</p>

<p>let x = 5u32; // this is a statement</p>

<p>let y = {
    let x_squared = x * x;
    let x_cube = x_squared * x;</p>

<pre><code>// This expression will be assigned to `y`
x_cube + x_squared + x };
</code></pre>

<p>let z = {
    // The semicolon suppresses this expression and <code>()</code> is assigned to <code>z</code>
    2 * x;
};
```</p>

<h3 id="ownership-model-stack-vs-heap">Ownership model: Stack vs heap</h3>

<p>Rust‚Äôs memory/ownership model is, to me, its main killer feature; it gives you tighter control over the way your program consumes memory while maintaining memory-safety, all without having to ship a garbage collector with the runtime. You get to decide whether to pass things by value or by reference as well as mutability of bindings (including when pattern matching).</p>

<p>There is also the matter of <em>where</em> things get allocated. In Scala (and perhaps with most JVM-based languages), there are a set of rules that decide whether or not something gets put on the stack or on the heap (and thus incur the future cost of garbage collection). In general, the only time something gets allocated on the stack are primitives that do not escape methods as fields of objects, and references to objects which themselves get allocated on the heap. There might be fun runtime tricks the runtime environment does, like escape analysis, but overall, you don‚Äôt get to choose.</p>

<p>In Rust, you can choose to allocate things on the heap by instantiating them inside (or transferring ownership of them to) data structures such as <code>Box</code>es or <code>Vec</code>s, etc. Or you can choose to work with plain values. You get to pick your abstraction based on the cost you want to pay for the features and guarantees they offer, such as safe multi-thread access (<a href="http://manishearth.github.io/blog/2015/05/27/wrapper-types-in-rust-choosing-your-guarantees/">this page</a> is a great reference point). Either way, Rust‚Äôs ownership system will, at compile time, make sure that you won‚Äôt get data races caused by, for instance, modifying naked values in different threads with no access control.</p>

<p>Scala‚Äôs doesn‚Äôt give its users the same level of control, so naturally there is some adjustment to be made. However, contrary to the experiences of some others, I didn‚Äôt find the ownership stuff <strong>too</strong> hard to understand and get used to. Having experience with Scala‚Äôs rich type system meant that the lifetime annotation stuff was quite easy to come to grips with. Maybe doing C and C++ in Comsci courses in university helped too.</p>

<ul>
  <li><strong>Note</strong>: If you‚Äôre a glass-half-full kind of person, I guess you can say that Rust <em>forces</em> you to take control rather than <em>gives</em> you control. It‚Äôs all a matter of perspective ‚Ä¶</li>
  <li><strong>Note 2</strong>: If you find yourself doing lots of <code>.clone()</code>s to get the compiler off your back, maybe you‚Äôre doing something not quite right.</li>
</ul>

<h4 class="no_toc" id="mutability"><strong>Mutability</strong></h4>

<p>Mutability deserves to be mentioned separately. If you‚Äôre coming from years of Scala (or pretty much any other language that stresses immutability and referential transparency as the road to enlightenment), writing your first <code>let mut</code> or <code>&amp;mut self</code> can feel dirty.</p>

<p>It took me a while to get used to the idea, but hey, when in Rome, right? If it helps, remember that Rust is focused on speed and efficiency through (near, or actually) zero-cost abstractions and that, thanks to its strict ownership model, data races due to mutability are not a problem.</p>

<h2 id="things-i-wish-were-different">Things I wish were different</h2>

<h3 id="async-io">Async IO</h3>

<p>In Scala, most frameworks that deal with any sort of IO have embraced non-blocking IO by utilising some kind of wrapper data type, such as <code>Future[A]</code>, <code>Task[A]</code>, or <code>IO[A]</code> (usually a Monad), that separates the description of your program from its execution, and identify, by type, the effect of talking with the scary and dirty outside world. This allows you to not block the executing thread when waiting for stuff to happen (such as data to come back) by choosing a suitable execution strategy.</p>

<p>In Rust land, most of the widely-used libraries that I‚Äôve seen, such as the Redis client, and and Hyper (and all the various things built on it, such as Rusoto, Rocket, etc) are all blocking. While this works okay for stuff like single-user utilities, this is suboptimal for applications that are IO heavy and need to serve a large number of concurrent users because your application‚Äôs threads can get tied up just waiting for data, leaving it unable to serve other requests. Or, you end up with potentially huge thread pools (√† la old school Java Servlet apps..), which seems to go against Rust‚Äôs spirit of efficiency.</p>

<p>Having said that I know that advances are being made in this area:</p>

<ul>
  <li><a href="https://tokio.rs/">Tokio</a>, ‚Äútokenised IO‚Äù, an async IO framework that exposes a Future-based API is making lots of progress. Looks production-ready.</li>
  <li><a href="https://github.com/hyperium/hyper">Hyper</a>, the defacto HTTP client server framework, is going to hit 0.11 soon, which will bring with it a Futures-based API based on Tokio. This will likely (I hope) cascade down to any libs based on Hyper.</li>
</ul>

<p>Also, as of now, it‚Äôs painful to transform and return Futures from functions because every transformation causes the concrete type of your object to get chained and tagged with an arbitrary closure type. Since writing the result type is non-optional in Rust, the current solution is to declare your return type as <code>Box&lt;Future&lt;A&gt;&gt;</code>, but it‚Äôs less efficient at runtime because boxed <a href="https://doc.rust-lang.org/book/trait-objects.html">trait objects</a> necessitate dynamic dispatch and heap allocation. Hopefully soon ‚Äúimpl Trait‚Äù will be released to address this issue (<a href="https://github.com/rust-lang/rust/issues/34511">tracking RFC</a>)</p>

<h3 id="strings">Strings</h3>

<p>In Rust there are a number of ways to represent Strings. Here are a few:</p>

<ul>
  <li><code>String</code> runtime string value, with its contents allocated on the heap</li>
  <li><code>&amp;'a str</code> string with a lifetime
    <ul>
      <li><code>&amp;' static str</code> string with static lifetime (baked into your binary)</li>
    </ul>
  </li>
  <li><code>Vec&lt;u8&gt;</code></li>
</ul>

<p>While I‚Äôve mostly gotten used to this by now and understand the purpose of having each one, I hope the ergonomics initiative can make this situation better to understand, since strings are so ubiquitous. How? I have no idea..maybe I‚Äôm just ranting.</p>

<h3 id="cross-compiling">Cross compiling</h3>

<p>Obviously, Scala devs are used to compiling once and running the same binaries everywhere thanks to the JVM (mostly :p). While I don‚Äôt expect the same for Rust because it compiles to native machine code, I do wish the cross-compilation tools were better out of the box (for example, like <a href="https://dave.cheney.net/2015/08/22/cross-compilation-with-go-1-5">it is in Golang</a>).</p>

<p>At the moment, depending on the target platform, cross-compilation for Rust is a bit involved and there are several options:</p>

<ol>
  <li>Adding a target toolchain via Rustup and possibly installing some more packages specifically for your target platform (as in <a href="https://hackernoon.com/compiling-rust-for-the-raspberry-pi-49fdcd7df658">this guide</a>)</li>
  <li>Using a pre-built Docker container that holds all the settings/environment variables/installations needed to compile to your target platform (see <a href="https://github.com/Ragnaroek/rust-on-raspberry-docker">rust-on-raspberry-docker</a>)</li>
  <li>Using the <a href="https://github.com/japaric/cross"><code>cross</code></a>, cargo tool that seems like it automates 2.</li>
</ol>

<p>My use case is building for my Raspberry Pi and I‚Äôve only tried the first 2, but that last one looks to be the winner here and it would be awesome to see something like that included by default as part of rustup or cargo.</p>

<h3 id="odd-headscratchers">Odd headscratchers</h3>

<p>Just a few things I still don‚Äôt quite get:</p>

<h4 class="no_toc" id="do-we-actually-need-ref"><strong>Do we actually need <code>ref</code>?</strong></h4>

<p>In my opinion, <code>ref</code> is unnecessarily confusing. From what I can tell, it‚Äôs mostly used for binding pointers during pattern matching</p>

<p><code>rust
match some_int {
  // Why not Some(&amp; s) =&gt; ... ???
  Some(ref s) =&gt; println!("{}",s),
  None =&gt; unreachable!()
}
</code></p>

<h4 class="no_toc" id="mut"><strong><code>&amp;mut</code></strong></h4>

<p>When handing out references of something bound with let mut, why do i need to do <code>&amp;mut</code> instead of just <code>&amp;</code> ?</p>

<p>```rust
// This uses mut for no reason other than to prove a point.
fn non_empty(s: &amp;mut String) -&gt; bool { s.len() &gt; 0 }</p>

<p>let mut string = ‚Äúhello‚Äù.to_string();
hello(&amp;mut string); // why can‚Äôt this just be hello(&amp; string) ??
```</p>

<h4 class="no_toc" id="scoping-of-lifetimes-with-braces"><strong>Scoping of lifetimes with braces</strong></h4>

<p>I somehow managed to code my way into a deadlock when using <code>RWLock</code> because the lifetime-scoping behaviour of <code>{}</code> braces when used with pattern matching is, in my opinion, non-intuitive. If you‚Äôre interested, more about it in <a href="https://github.com/rust-lang/rust/issues/37612">this issue</a>.</p>

<h3 id="gimme">Gimme</h3>

<p>I know these things are in the pipeline but I wish they were in Rust yesterday:</p>

<ol>
  <li>Higher kinded types</li>
  <li>‚ÄúSpecialisation‚Äù, aka finding the most specific implementation of a traits according to the type of value at the call site. Right now, if you implement a Rust trait <code>for A</code>, then it clashes with every other implementation you write. Specialisation should remedy that (<a href="https://github.com/rust-lang/rust/issues/31844">tracking RFC</a>)</li>
  <li>A REPL. There‚Äôs <a href="https://github.com/murarth/rusti">Rusti</a> but I think Rust is missing a trick by not supplying one out-of-the-box, especially when it‚Äôs got such a strong dev-env-setup game.</li>
  <li>Some kind of <code>do</code> or <code>for</code> comprehension for working with container types (there are libs out there but built-in would be nice)</li>
</ol>

<h2 id="conclusion">Conclusion</h2>

<p>That concludes my take on what it‚Äôs like to use Rust, from a Scala dev‚Äôs perspective, one year on, in 2017. Overall I‚Äôm very happy that the me a year ago decided to look into Rust. It‚Äôs been a fun and exciting ride: for a while it felt like every few months I was getting new toys that I could immediately use: type macros and custom derives were game changers because they made it ergonomic to write <a href="https://beachape.com/frunk/frunk/macro.Hlist.html">Hlist types</a> by hand, and made <a href="https://beachape.com/frunk/frunk_core/generic/trait.Generic.html">Generic</a>/<a href="https://beachape.com/frunk/frunk_core/labelled/trait.LabelledGeneric.html">LabelledGeneric</a> practical, respectively.</p>

<p>Overall, I believe there are a lot of things in Rust for Scala engineers to like. The community is friendly and diverse so you can easily find a library that interests you to get involved in (shameless plug: contributions to <a href="https://github.com/lloydmeta/frunk">frunk</a> are always welcome). Or, you can do your own side project and write a small system utility or program a microcontroller; online resources are very easy to find. In any case, with Rust, you really can‚Äôt say it‚Äôs hard to get started !</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Boilerplate-free Struct Transforms in Rust.]]></title>
    <link href="https://beachape.com/blog/2017/04/12/boilerplate-free-struct-transforms-in-rust/"/>
    <updated>2017-04-12T12:45:00+00:00</updated>
    <id>https://beachape.com/blog/2017/04/12/boilerplate-free-struct-transforms-in-rust</id>
    <content type="html"><![CDATA[<p>The last several posts have introduced a number of abstractions, namely HList, Generic, LabelledGeneric, as well as <code>pluck()</code> and <code>sculpt()</code>. Although each of those have impressive party tricks of their own, I‚Äôd like to share how you can use them to write a reuseable, generic function that handles converting between structs with mis-matched fields and thus have different <code>LabelledGeneric</code> representations.</p>

<p><img class="center" src="/images/optimus-prime.gif" title="‚ÄòAll together now‚Äô" ></p>

<p>Unlike the last post, this one will be relatively light on recursion and mind-bending type-level stuff; it‚Äôs time to sit back and enjoy the fruits of our labour.</p>

<!-- more -->

<h2 id="adding-frunk-to-your-project">Adding Frunk to your project</h2>

<p>Much of this post will make use of <a href="https://github.com/lloydmeta/frunk">Frunk‚Äôs</a> types (e.g. <code>HCons</code>, <code>HNil</code>), methods, macros (esp. for describing macro types via the <code>Hlist!</code> <a href="https://beachape.com/frunk/frunk_core/macro.Hlist.html">type macro</a>), and terminology.</p>

<p>It might be easier to follow along if you add Frunk to your project and play around with it. <a href="https://github.com/lloydmeta/frunk">Frunk</a> is published to <a href="//crates.io/crates/frunk">Crates.io</a>, so to add it your list of dependencies, simply put this in your <code>Cargo.toml</code>:</p>

<p><a href="https://crates.io/crates/frunk"><img src="https://img.shields.io/crates/v/frunk.svg" alt="Crates.io" /></a></p>

<p><code>rust
[dependencies]
frunk = "${latest_version}"
</code></p>

<p>Alternatively, take a look at the <a href="https://beachape.com/frunk">published Rustdocs</a>.</p>

<h2 id="boilerplate-free-conversions-between-structs">Boilerplate-free conversions between Structs</h2>

<p>Suppose we have a bunch of structs that are similar-ish in terms of their data but ultimately, not necessarily
exactly the same. This means we can‚Äôt just use the normal <code>LabelledGeneric</code> <code>convert_from</code> method to convert between them.</p>

<p>```rust
#[derive(LabelledGeneric)]
struct UserFromDb&lt;‚Äôa&gt; {
    id: u64,
    first_name: &amp;‚Äôa str,
    last_name: &amp;‚Äôa str,
    email: &amp;‚Äôa str,
    age: u32,
    pw_hash: &amp;‚Äôa str,
    is_admin: bool,
    created_at: i64
}</p>

<p>// Holds User data for rendering in a front-end view
// or for sending over an API. Striped of any sensitive
// information
#[derive(LabelledGeneric)]
struct PresentableUser&lt;‚Äôa&gt; {
    last_name: &amp;‚Äôa str,
    first_name: &amp;‚Äôa str,
    age: u32,
    created_at: i64
}</p>

<p>// Holds data for sending a User over our internal API
#[derive(LabelledGeneric)]
struct InternalApiUser&lt;‚Äôa&gt; {
    id: u64,
    first_name: &amp;‚Äôa str,
    last_name: &amp;‚Äôa str,
    age: u32,
    email: &amp;‚Äôa str,
    is_admin: bool,
    created_at: i64
}
```</p>

<p>In our example, <code>PresentableUser</code> and <code>InternalApiUser</code> structs have fields that are subsets of the fields in <code>UserFromDb</code>, and not in the same order either. The scenario is that <code>UserFromDb</code> is a struct that we get from reading our persistence layer, and the other 2 are types that we use in our application for business logic.</p>

<p>Assuming a flow where we want to be able to go from <code>UserFromDb</code> to either <code>PresentableUser</code> or <code>InternalApiUser</code>, the idea is that we don‚Äôt want be holding on to sensitive data like <code>pw_hash</code> when we don‚Äôt need to, thus lowering the risk of accidentally leaking said data (e.g. serialising it by accident, or by rendering it in debug messages, etc).</p>

<p>While we could go about writing <code>From</code>s by hand for each of these, and for every other time a similar situation arises, that‚Äôs quite a lot of boilerplate to write and maintain. Thankfully, we can make use of Frunk‚Äôs <code>LabelledGeneric</code> and <code>Sculptor</code> to write a single, reuseable generic function.</p>

<p>Note, for a review of:</p>

<ul>
  <li><code>LabelledGeneric</code>, see <a href="/blog/2017/03/04/labelledgeneric-in-rust-what-why-how/">this post</a></li>
  <li><code>Sculptor</code>, see <a href="/blog/2017/03/12/gentle-intro-to-type-level-recursion-in-Rust-from-zero-to-frunk-hlist-sculpting/">this post</a></li>
</ul>

<p><code>rust
/// Converts from another type A into B assuming that A and B have labelled generic representations
/// that can be sculpted into each other.
///
/// Note that this method tosses away the "remainder" of the sculpted representation.
fn transform_from&lt;A, B, Indices&gt;(a: A) -&gt; B
    where A: LabelledGeneric,
          B: LabelledGeneric,
// The labelled representation of A must be sculpt-able into the labelled representation of Self
          &lt;A as LabelledGeneric&gt;::Repr: Sculptor&lt;&lt;B as LabelledGeneric&gt;::Repr, Indices&gt; {
    // Turn A into its labelled generic representation
    let a_gen = &lt;A as LabelledGeneric&gt;::into(a);
    // Sculpt the generic labelled representation of A into the labelled generic representation
    // of B. We ignore the remainder.
    let (b_gen, _): (&lt;B as LabelledGeneric&gt;::Repr, _) = a_gen.sculpt();
    // Turn the lablled generic representation of B into B
    &lt;B as LabelledGeneric&gt;::from(b_gen)
}
</code></p>

<p>Not bad. The body of the function is literally 3 lines long :) Now we can do this:</p>

<p>```rust
let u_db = UserFromDb {
    id: 3,
    first_name: ‚ÄúJoe‚Äù,
    last_name: ‚ÄúBlow‚Äù,
    email: ‚Äújoe@gmail.com‚Äù,
    age: 30,
    pw_hash: ‚Äúasd35235adsf‚Äù,
    is_admin: true,
    created_at: 12345,
};</p>

<p>let p_user: PresentableUser = transform_from(udb);
// or
let i_user: InternalApiUser = transform_from(udb);
```</p>

<p>In actuality, Frunk already <a href="https://beachape.com/frunk/frunk_core/labelled/fn.transform_from.html">ships with this function</a> so you can use it out of the box.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Often times, you‚Äôll hear that heterogeneous lists enable developers to write reuseable generic functions because they abstract over arity and types, and it might not be obvious exactly what that means on a practical level. The example shown in this post just scratches the surface of what is made possible through <code>HList</code> and <code>LabelledGeneric</code>, and there are definitely more creative usages out there, such as building of boilerplate-free (e.g. JSON) codecs (hint: look to Haskell and Scala libs for more).</p>

<p>As usual, please give it a spin and chime in with any questions, corrections, and suggestions !</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gentle Intro to Type-level Recursion in Rust: From Zero to HList Sculpting.]]></title>
    <link href="https://beachape.com/blog/2017/03/12/gentle-intro-to-type-level-recursion-in-Rust-from-zero-to-frunk-hlist-sculpting/"/>
    <updated>2017-03-12T12:03:00+00:00</updated>
    <id>https://beachape.com/blog/2017/03/12/gentle-intro-to-type-level-recursion-in-Rust-from-zero-to-frunk-hlist-sculpting</id>
    <content type="html"><![CDATA[<blockquote>
  <p>Getting the type signature right was 99% of the work in implementing <code>pluck</code> and <code>sculpt</code> for <code>HList</code>s in Frunk.</p>

  <p>Here‚Äôs what I‚Äôve learnt along the way: what works, and what doesn‚Äôt work (and why).</p>
</blockquote>

<p>As you may already know, Rust eschews the now-mainstream object-oriented model of programming (e.g. in Java, where behaviour for a type is added to the type/interface definition directly) in favour of a typeclass-like approach (e.g. in Haskell where you can ad-hoc add behaviour to a type separate from the type definition itself).  Both approaches have their merits, and indeed, some languages, such as Scala, allow for a mix of both.</p>

<p>For those coming from the OOP school of programming, Rust‚Äôs system of adding behaviour to types might be daunting to come to grips with. At a glance, it might not be obvious how to get things done, especially when what you want to build goes beyond implementing <code>Debug</code> or <code>Eq</code>. If your abstraction has a certain degree of type-level recursiveness, it might be even harder to see the light at the end of the tunnel, and the lack of online material covering that sort of thing doesn‚Äôt help.</p>

<p>As a Scala guy with Haskell knowledge, I‚Äôm no stranger to typeclasses, but it took me a while and several failed attempts to figure out how to implement the following:</p>

<ol>
  <li>Plucking out a value by type from an HList and getting back the remainder **</li>
  <li>Sculpting an HList into another shape, and getting back the remainder (in the case where we only want a smaller subset than the original) **</li>
</ol>

<p>Of course, the type signature of the finished product can be intimidating !</p>

<p><img class="center" src="/images/sculptor-typesig.png" title="‚Äò6 type parameters, 1 fills in a type parameter on the trait that is recursive, and a recursive associated type. WTF? ‚Äò" ></p>

<p>In this post, I‚Äôll briefly introduce Rust‚Äôs trait system and present my mental model for writing trait implementations that deal with type-level recursion. To do so, I will go through how <code>pluck()</code> and <code>sculpt()</code> were written in Frunk, as well as recount some of my failed approaches so you can learn from my mistakes.</p>

<p>Hopefully, by the end of it, you‚Äôll be able to look at signatures like the one above and not go ‚ÄúWTF‚Äù, but rather, ‚ÄúFTW‚Äù.</p>

<!-- more -->

<h2 class="no_toc" id="type-level-recursion">‚ÄúType-level recursion‚Äù?</h2>

<p>Ok, I may be butchering/making up a term, but by ‚Äútype-level recursion‚Äù, I‚Äôm referring to recursive expansions/evaluations of types  at compile-time, particularly for the purpose of proving that a certain typeclass instance exists at a function call site. This is distinct from runtime ‚Äúvalue‚Äù-level recursion that occurs when you call a function that calls itself.</p>

<p>If you‚Äôre having trouble understanding the difference:</p>

<ul>
  <li><strong>Value-level recursion</strong>: If it can‚Äôt find an exit condition, your program is stuck running forever.</li>
  <li><strong>Type-level recursion</strong>: If it can‚Äôt expand/find the exit-type, your compiler will either give up or never finish compiling; you won‚Äôt even have a program to run.</li>
</ul>

<h2 class="no_toc" id="outline">Outline</h2>
<ul id="markdown-toc">
  <li><a href="#basic-gist-of-rust-typeclasses-traits">Basic Gist of Rust typeclasses (traits)</a>    <ul>
      <li><a href="#dependent-trait-implementations">Dependent trait implementations</a></li>
      <li><a href="#mental-model-for-type-level-recursion">Mental model for type-level recursion</a>        <ul>
          <li><a href="#recursion-on-the-value-level">Recursion on the value level</a></li>
          <li><a href="#recursion-on-the-type-level">Recursion on the type level</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#what-the-frunk">What the Frunk?</a></li>
  <li><a href="#plucking-from-hlists">Plucking from HLists</a>    <ul>
      <li><a href="#implementation-intuition">Implementation intuition</a></li>
      <li><a href="#first-attempt">First attempt</a></li>
      <li><a href="#second-attempt">Second attempt</a></li>
      <li><a href="#type-level-walkthrough">Type-level walkthrough</a></li>
    </ul>
  </li>
  <li><a href="#sculpting-hlists">Sculpting HLists</a>    <ul>
      <li><a href="#implementation-intuition-1">Implementation intuition</a></li>
      <li><a href="#first-attempt-1">First attempt</a></li>
      <li><a href="#second-attempt-1">Second attempt</a></li>
    </ul>
  </li>
  <li><a href="#conclusion">Conclusion</a>    <ul>
      <li><a href="#credit">Credit</a></li>
    </ul>
  </li>
</ul>

<h2 id="basic-gist-of-rust-typeclasses-traits">Basic Gist of Rust typeclasses (traits)</h2>

<p>In Rust, typeclass is spelt <code>trait</code>, and although that word is somewhat ambiguous and overloaded with different meanings depending on context (e.g. in Scala), I‚Äôll try to stick with it throughout this article. Subsequently, a typeclass instance is called an ‚Äúimplementation‚Äù (<code>impl</code> in code) in Rust.</p>

<p>Here is a basic example of a simple trait and implementation for a type <code>Circle</code>, taken from the official <a href="https://doc.rust-lang.org/book/traits.html">Rust book</a>.</p>

<p>```rust
// A trait that allows you to call ‚Äúarea‚Äù on something
trait HasArea {
    fn area(&amp;self) -&gt; f64;
}</p>

<p>// Our type
struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}</p>

<p>// Our implementation of HasArea for Circle
impl HasArea for Circle {
    fn area(&amp;self) -&gt; f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
}
```</p>

<p>For comparison, here is the Haskell equivalent</p>

<p>```haskell
‚Äì Our typeclass
class HasArea a where
  area :: a -&gt; Float</p>

<p>‚Äì Our type
data Circle = Circle { x :: Float, y :: Float, radius :: Float }</p>

<p>‚Äì Our typeclass instance for Circle
instance HasArea Circle where
  area c = pi * radius c ^ 2
```</p>

<p>In both of these cases, what we see is</p>

<ol>
  <li>There is a trait, <code>HasArea</code>, which describes behaviour (must implement an <code>area</code> function that takes as its first argument the implementing type) for types that want to belong to, or join it.</li>
  <li>Next, we have a type, <code>Circle</code>, which has one purpose: hold data.</li>
  <li>Then, we add <code>Circle</code> to the <code>HasArea</code> trait by implementing an instance of the trait, fulfilling the contract by writing the <code>area</code> function.</li>
</ol>

<p>The key difference between this approach and the OOP approach is that adding behaviour to an existing type does not require us to edit the original type declaration, nor does it require us to create a wrapper type. This allows us to add behaviour to types that do not belong to us (e.g. we don‚Äôt have access to its source)! This flexibility is a key advantage of the typeclass/trait approach. For a much more detailed comparison between OOP and typeclasses (traits), checkout this <a href="https://wiki.haskell.org/OOP_vs_type_classes">wiki entry on haskell.org</a>.</p>

<h3 id="dependent-trait-implementations">Dependent trait implementations</h3>

<p>Sometimes, you‚Äôll want to write trait implementations for data types that have one or more type parameters. In these cases, your trait implementation will likely require that implementations of the trait exist for each of those type parameters.</p>

<p>For example</p>

<p>```rust
// The Add trait, which exists in core::ops, copied verbatim here.
//
// Note that the Add trait has a right hand side (RHS) type parameter
// to represent the type that the implementing trait is being added
// with.
pub trait Add&lt;RHS=Self&gt; {
    /// The resulting type after applying the <code>+</code> operator
    #[stable(feature = ‚Äúrust1‚Äù, since = ‚Äú1.0.0‚Äù)]
    type Output;</p>

<pre><code>/// The method for the `+` operator
#[stable(feature = "rust1", since = "1.0.0")]
fn add(self, rhs: RHS) -&gt; Self::Output; }
</code></pre>

<p>// Our Cup struct. We signal that its contents can be
// anything because it has an unrestricted type parameter
// of A
struct Cup<a> {
    content: A,
}</a></p>

<p>// In our case, we want to implement Add&lt;Cup<a>&gt; because we want to add
// 2 cups with the same content type together, but we don‚Äôt know in
// advance what kind of content would be in them; hence we keep
// it parameterised with A.
//
// Thus, we write an implementation of Cup for Add, but add a restriction:
// the implementation only exists for Cups where the content is bound to a
// type that is already implements the Add trait (thus ‚ÄúA: Add<a>‚Äù)
impl&lt;A: Add<a>&gt; Add&lt;Cup<a>&gt; for Cup<a>
{
    // This is what is called an associated type.
    // Here, Output is the type that will be returned
    // from the add operation
    type Output = Cup¬´¬†A as Add<a> &gt;::Output&gt;;</a></a></a></a></a></a></p>

<pre><code>fn add(self, rhs: Cup&lt;A&gt;) -&gt; Self::Output {
    // Here we make use of the Add trait for A to add
    // the contents from both cups together
    let added_content = self.content.add(rhs.content);
    Cup { content: added_content }
} } ```
</code></pre>

<p>Making <code>Cup</code> part of the <code>Add</code> typeclass will allow us to call <code>cup_a + cup_b</code>, which is kind of neat. One thing to take note of here is the <code>Output</code> associated type. Pay attention to the fact that in our implementation of <code>Add</code> for <code>Cup</code>, the type of <code>Output</code> is <code>Cup&lt;&lt; A as Add&lt;A&gt; &gt;::Output&gt;</code>, which means that ultimately, the output of <code>Add</code>ing of 2 <code>Cup&lt;A&gt;</code>s will depend on what the <code>Output</code> of <code>Add&lt;A&gt;</code> is.  The <code>&lt; A as Add&lt;A&gt; &gt;</code> part can be read as ‚Äúsummon the <code>Add&lt;A&gt;</code> implementation for the type A‚Äù (the compiler will do the actual lookup work here; if one doesn‚Äôt exist, your code will fail to compile), and the <code>::Output</code> following it means ‚Äúretrieve the associated type, Output, from <em>that</em> implementation‚Äù. Let this sink in, because it‚Äôs important in order for us to move towards the concept of type-level recursion for traits.</p>

<p>Here is another way to write the same thing: using <a href="https://doc.rust-lang.org/book/traits.html#where-clause">where clause</a> syntax, so that the restriction goes at the end of the initial type signature in our implementation declaration. This is useful when you have more than 2 or 3 type parameters for your typeclass instance and you have a complex set of restraints. Using <code>where</code> can help cut down on initial noise.</p>

<p>```rust
impl<a> Add&lt;Cup<a>&gt; for Cup<a>
    where A: Add<a>
{
    type Output = Cup¬´A as Add<a>&gt;::Output&gt;;</a></a></a></a></a></p>

<pre><code>fn add(self, rhs: Cup&lt;A&gt;) -&gt; Self::Output {
    let added_content = self.content.add(rhs.content);
    Cup { content: added_content }
} } ```
</code></pre>

<p>Here‚Äôs another, more general implementation of <code>Add</code> for <code>Cup</code>. It‚Äôs more general because it lets us add <code>Cup</code>s of <em>different</em> content types, provided that there exists an <code>Add&lt;B&gt;</code> implementation for whatever concrete type is bound to <code>A</code> in any given <code>Cup&lt;A&gt;</code>.</p>

<p>```rust
// Instead of just A, we introduce another type parameter, B, which
// is passed as the type parameter for the Cup that we want to add with
impl&lt;A, B&gt; Add&lt;Cup<b>&gt; for Cup<a>
    // This next line means ‚ÄúA must have an Add<b> implementation‚Äù
    where A: Add<b>
{
    // The Output associated type now depends on the Output of &lt;A as Add<b>&gt;
    type Output = Cup¬´A as Add<b>&gt;::Output&gt;;</b></b></b></b></a></b></p>

<pre><code>fn add(self, rhs: Cup&lt;B&gt;) -&gt; Self::Output {
    // Notice that we can use the operator "+"
    let added_content = self.content + rhs.content;
    Cup { content: added_content }
} } ```
</code></pre>

<h3 id="mental-model-for-type-level-recursion">Mental model for type-level recursion</h3>

<p>By this point, we have covered most of the basic understanding required to write more complex traits and implementations. To recap, they are:</p>

<ol>
  <li>The differences between a trait, a type, and a trait implementation</li>
  <li>How to use bounds (<code>A: Add&lt;A&gt;</code> or <code>where</code> clauses) when writing implementations for generic types</li>
  <li>How to summon an implementation for a given type (<code>&lt;A as Display&gt;</code>)</li>
  <li>How to write and use associated types (see <code>Output</code> in the above examples)</li>
</ol>

<p>For a more thorough introduction to Rust‚Äôs trait system, by all means refer to the official Rust <a href="https://doc.rust-lang.org/book/traits.html">docs on traits</a>.</p>

<p>Before going any further, I‚Äôd like to provide you with my mental model of how to think about recursion on the <em>type level</em>.</p>

<h4 id="recursion-on-the-value-level">Recursion on the value level</h4>
<blockquote>
  <p>You write a function that keeps calling itself until an exit condition is met, then returns a value.</p>
</blockquote>

<h4 id="recursion-on-the-type-level">Recursion on the type level</h4>
<blockquote>
  <p>You write implementations of your trait for exit-types and work-to-be-done types. In order to prove an implementation of your trait exists for a concrete type at a function call site, the compiler will try to lookup and expand/expand types recursively until it can figure out a concrete implementation to use, or gives up with an error.</p>
</blockquote>

<p>This may not make much sense at the moment, but hopefully it will soon.</p>

<h2 id="what-the-frunk">What the Frunk?</h2>

<p>Much of this post will make use of <a href="https://github.com/lloydmeta/frunk">Frunk‚Äôs</a> types (e.g. <code>HCons</code>, <code>HNil</code>), methods, macros (esp. for describing macro types via the <code>Hlist!</code> <a href="https://beachape.com/frunk/frunk_core/macro.Hlist.html">type macro</a>), and terminology.</p>

<p>It might be easier to follow along if you add Frunk to your project and play around with it.  <a href="https://github.com/lloydmeta/frunk">Frunk</a> is published to <a href="//crates.io/crates/frunk">Crates.io</a>, so to add it your list of dependencies, simply put this in your <code>Cargo.toml</code>:</p>

<p><a href="https://crates.io/crates/frunk"><img src="https://img.shields.io/crates/v/frunk.svg" alt="Crates.io" /></a></p>

<p><code>rust
[dependencies]
frunk = "${latest_version}"
</code></p>

<p>Alternatively, take a look at the <a href="https://beachape.com/frunk">published Rustdocs</a>.</p>

<h2 id="plucking-from-hlists">Plucking from HLists</h2>

<p>Given an <a href="/blog/2016/10/23/rust-hlists-heterogenously-typed-list/">HList</a>, how can we write a function that allows us to pluck out a value by type (if the <code>HList</code> does not contain this type, the compiler should let us know), and also return the rest of the <code>HList</code>?</p>

<p>Suppose we call this function <code>pluck()</code>, it should behave like so:</p>

<p>```rust
// h has type Hlist![ {integer}, &amp;str, f32, bool ]
let h = hlist![ 1, ‚ÄúJoe‚Äù, 42f32, true ];</p>

<p>// We tell it the target type, and let the compiler infer the rest
let (target, remainder): (f32, _) = h.pluck();</p>

<p>assert_eq!(target, 42f32);
assert_eq!(remainder, hlist![1, ‚ÄúJoe‚Äù, true]);
```</p>

<h4 id="implementation-intuition">Implementation intuition</h4>

<p>Our basic logic is fairly simple, given an <code>HList</code> and a <code>Target</code> type:</p>

<ol>
  <li>If the head of the Hlist matches the <code>Target</code> type, return the head of the Hlist and the tail of the Hlist as the remainder in a pair (2 element tuple)</li>
  <li>Otherwise,
    <ol>
      <li>Store the head in <code>current_head</code></li>
      <li>Call <code>pluck()</code> again on the tail of the current Hlist with the same <code>Target</code> type (i.e. recursively call 1. with the tail), and store the result in <code>(tail_target, tail_remainder)</code> pair.</li>
      <li>Return the target plucked from the tail, and prepend <code>current_head</code> to the remainder from the tail. Return both in a tuple like so: <code>(tail_target, HCons { head: current_head, tail: tail_remainder} )</code>.</li>
    </ol>
  </li>
</ol>

<h4 id="first-attempt">First attempt</h4>

<p>First, let‚Äôs assume we‚Äôll be working with a trait; call it <code>Plucker</code>. For now, let‚Äôs also assume that it will be parameterised with 1 type, the target type, and will also have an associated type, <code>Remainder</code>. There isn‚Äôt really a hard and fast rule for when you should use type parameters vs associated types, but if you‚Äôre interested, you can take a look at <a href="http://stackoverflow.com/questions/32059370/when-is-it-appropriate-to-use-an-associated-type-versus-a-generic-type">this Stackoverflow question</a> because Matthieu offers some great advice.</p>

<p>Personally, I always try use an associated type when I need to refer to the type from somewhere else (espescially recursively; more on this later). However, going with a type parameter is useful when you need to have different implementations of a trait for the same type in different circumstances. We saw this with <code>Add</code>, where the right hand side was a type parameter, <code>RHS</code>, allowing you to declare different <code>Add</code> implementations for the same left-hand-side type and letting the compiler find the correct implementation to use at <code>+</code> call sites depending on the type of thing being added with.</p>

<p>```rust
// Our trait
trait Plucker<target> {</target></p>

<p>type Remainder;</p>

<p>// Pluck should return the target type and the Remainder in a pair
  fn pluck(self) -&gt; (Target, Self::Remainder);
}
```</p>

<p>The ‚Äúexit-type‚Äù implementation is for when the current head of the <code>HList</code> contains the target type, so let‚Äôs jot that down that:</p>

<p>```rust
impl &lt;Target, Tail&gt; Plucker<target> for HCons&lt;Target, Tail&gt; {</target></p>

<p>// Target is the head element, so the Remainder type is the tail!
  type Remainder = Tail;</p>

<p>fn pluck(self) -&gt; (Target, Self::Remainder) {
    (self.head, self.tail)
  }
}
```</p>

<p>Now let‚Äôs implement the second piece; the non-trivial part where the target type is <em>not</em> in <code>Head</code>, but in the <code>Tail</code> of our HList. I‚Äôll sometimes refer to this as the ‚Äúwork-to-be-done‚Äù type.</p>

<p>```rust
impl &lt;Target, Head, Tail&gt; Plucker<target> for HCons&lt;Head, Tail&gt;
  where Tail: Plucker<target></target></target></p>

<p>// Target is in the tail, so we add the current head type to the remainder
  // And use the Tail‚Äôs Plucker‚Äôs Remainder type as the tail :)
  type Remainder = HCons&lt;Head, &lt;Tail as Plucker<target>&gt;::Remainder&gt;;</target></p>

<p>fn pluck(self) -&gt; (Target, Self::Remainder) {
    let (tail_target, tail_remainder): (Target, &lt;Tail as Plucker<target>&gt;::Remainder) = self.tail.pluck();
    (
      tail_target,
      HCons { head: self.head, tail: tail_remainder}
    )</target></p>

<p>}
}
```</p>

<p>Looks good right? But if you send that to the compiler, you‚Äôll be hit with this message:</p>

<p><code>bash
error[E0119]: conflicting implementations of trait `Plucker&lt;_&gt;` for type `frunk_core::hlist::HCons&lt;_, _&gt;`:
   --&gt; tests/example.rs:306:1
    |
296 |   impl &lt;Target, Tail&gt; Plucker&lt;Target&gt; for HCons&lt;Target, Tail&gt; {
    |  _- starting here...
297 | |
298 | |     // Target is the head element, so the Remainder type is the tail!
299 | |     type Remainder = Tail;
300 | |
301 | |     fn pluck(self) -&gt; (Target, Self::Remainder) {
302 | |         (self.head, self.tail)
303 | |     }
304 | | }
    | |_- ...ending here: first implementation here
305 |
306 |   impl &lt;Target, Head, Tail&gt; Plucker&lt;Target&gt; for HCons&lt;Head, Tail&gt;
    |   ^ conflicting implementation for `frunk_core::hlist::HCons&lt;_, _&gt;`
</code></p>

<p>What the Rust compiler is helpfully is telling us, is that it can‚Äôt distinguish between our two implementations, and if we look closely at the types, that is indeed true:</p>

<p>```rust
// exit (work done) type implementation
impl &lt;Target, Tail&gt;  Plucker<target> for HCons&lt;Target, Tail&gt;</target></p>

<p>// work-to-be-done implementation
impl &lt;Target, Head, Tail&gt; Plucker<target> for HCons&lt;Head, Tail&gt;
```</target></p>

<p>The <code>Plucker&lt;Target&gt;</code> part is exactly the same, and sure, we‚Äôve used <code>Target</code> instead of <code>Head</code> in the <code>for HCons&lt;..&gt;</code> part in the first case, but simply using different type parameters isn‚Äôt enough to distinguish between the two.</p>

<p>Furthermore, note that you can‚Äôt use the lack of constraints (or <code>where</code> clauses) to distinguish between implementations either. This is because the current lack of an implementation for a given type parameter doesn‚Äôt mean that it can‚Äôt be added later (see <a href="http://stackoverflow.com/a/39161143/1814775">this Stackoverflow questions</a> for more details).</p>

<p>Welp, back to the drawing board.</p>

<h4 id="second-attempt">Second attempt</h4>

<p>What we‚Äôve learnt is that we need to have another type parameter in order to distinguish the exit-type and the work-to-be-done-type implementations, so let‚Äôs add one to <code>Plucker</code>. Intuitively, we know that we want to have a way to distinguish between ‚Äúthe target is here in the HList‚Äù (exit) and ‚Äúthe target is over there in the HList‚Äù (recursion), so let‚Äôs call our type parameter <code>Index</code>.</p>

<p>```rust
// the new and improved Plucker trait
trait Plucker&lt;Target, Index&gt; {
    type Remainder;</p>

<pre><code>fn pluck(self) -&gt; (Target, Self::Remainder); } ```
</code></pre>

<p>Then, let‚Äôs add a type to identify the <code>index</code> for the exit-type implementation. We‚Äôll use an empty <code>enum</code> because we just want to have a type, and we don‚Äôt want it to be available at runtime (ensuring zero runtime cost for our type).</p>

<p>```rust
// This will be the type we‚Äôll use to denote that the Target is in the Head
enum Here {}</p>

<p>impl &lt;Target, Tail&gt; Plucker&lt;Target, Here&gt; for HCons&lt;Target, Tail&gt; {</p>

<p>// Target type is in the Head, so the Remainder type must be the tail!
  type Remainder = Tail;</p>

<p>fn pluck(self) -&gt; (Target, Self::Remainder) {
    (self.head, self.tail)
  }
}
```</p>

<p>What about the work-to-be-done-type? Let‚Äôs imagine a scenario where we want to pluck a <code>Target</code> of type <code>MagicType</code> (let‚Äôs assume it‚Äôs declared as <code>struct MagicType</code>, so a type with a single element in it), and we have the following <code>HList</code>s to <code>pluck()</code> from; what would the <code>Index</code> be?</p>

<ol>
  <li>
    <p><code>HNil</code></p>

    <p>Trick question, there is no <code>Index</code> because our target of <code>MagicType</code> isn‚Äôt here. The compiler should fail to find an instance/implementation of our trait.</p>
  </li>
  <li>
    <p><code>hlist[ MagicType ]</code> (this is syntactic sugar for <code>HCons&lt;MagicType, HNil&gt;</code>)</p>

    <p><code>Index</code> would clearly be our <code>Here</code> enum type</p>
  </li>
  <li>
    <p><code>hlist![ Foo, MagicType ]</code> (this is syntactic sugar for <code>HCons&lt;Foo, HCons&lt;MagicType, HNil&gt;&gt;</code>)</p>

    <p><code>Index</code> can‚Äôt be <code>Here</code>, but we know that in order for the compiler to be satisfied that it can reach our end-type in 1. <code>Here</code> needs to be <em>somewhere</em> inside the type, but we <em>can‚Äôt</em> just use it as is, otherwise we‚Äôll run into the same ‚Äúconflicting implementation‚Äù error as before. So, let‚Äôs introduce new type <code>There&lt;A&gt;</code>, that has one type parameter. In this case, the <code>Index</code> should resolve to <code>There&lt;Here&gt;</code> because the target type is in the head of the tail.</p>
  </li>
  <li>
    <p><code>hlist![ Foo, Foo, MagicType ]</code></p>

    <p>Following from 3. <code>Index</code> would have to be <code>There&lt;There&lt;Here&gt;&gt;</code></p>
  </li>
  <li>
    <p><code>hlist![ Foo, Foo, Foo, MagicType ]</code></p>

    <p>What else could <code>Index</code> be but <code>There&lt;There&lt;There&lt;Here&gt;&gt;&gt;</code></p>
  </li>
</ol>

<p>That Looks alright, so let‚Äôs give it a go. Since the new type has a type parameter but no real data to associate it with, we‚Äôll need use the <code>PhantomData</code> trick (discussed in <a href="blog/2017/03/04/labelledgeneric-in-rust-what-why-how/#fieldname-type">the last post</a>).</p>

<p>```rust
// Type for representing a not-here Index
struct There<t>(PhantomData<t>);</t></t></p>

<p>impl&lt;Head, Tail, Target, TailIndex&gt; Plucker&lt;Target, There<tailindex>&gt; for HCons&lt;Head, Tail&gt;
    // This where clause can be interpreted as "the target must be pluckable from the Tail"
    where Tail: Plucker&lt;Target, TailIndex&gt;
{
    type Remainder = HCons&lt;Head, &lt;Tail as Plucker&lt;Target, TailIndex&gt;&gt;::Remainder&gt;;</tailindex></p>

<pre><code>fn pluck(self) -&gt; (Target, Self::Remainder) {
    let (target, tail_remainder): (Target, &lt;Tail as Plucker&lt;Target, TailIndex&gt;&gt;::Remainder) =
        &lt;Tail as Plucker&lt;Target, TailIndex&gt;&gt;::pluck(self.tail);
    (target,
     HCons {
         head: self.head,
         tail: tail_remainder,
     })
} } ```
</code></pre>

<p>And that‚Äôs it, we‚Äôve written implementations of <code>Plucker</code> for <code>HList</code>. The implementation for work-to-be-done type is type-recursive in its <code>Index</code> type as well as its <code>Remainder</code> associated type. The cool thing is that the compiler is in charge of figuring out what the <em>concrete</em> types should be at any given <code>pluck()</code> call-site. In fact, you can see <a href="https://beachape.com/frunk/frunk_core/hlist/trait.Plucker.html">from this example</a> in Frunk that the compiler will also happily infer the remainder for us too.</p>

<h3 id="type-level-walkthrough">Type-level walkthrough</h3>

<p>Let‚Äôs take a step back and work through what we‚Äôve done.</p>

<p>We‚Äôve declared an implementation of <code>Plucker</code> for the trivial exit-type (<code>Target</code> is in the head).</p>

<p>We‚Äôve also declared an implementation for the work-to-be-done type (<code>Target</code> is in the tail). This implementation, however, is dependent on its recursive types of <code>Tail</code> and <code>TailIndex</code> (hint: look at the <code>where</code> clause).  Intuitively speaking, an implementation of this type only exists if the current HList‚Äôs <code>Tail</code> has either:</p>

<ol>
  <li>An implementation for the exit-type; the <code>Target</code> type is in the head</li>
  <li>Another work-to-be-done implementation of <code>Plucker</code>. This ultimately means that <em>eventually</em> there has to be a 1. in the tail <em>somewhere</em>.</li>
</ol>

<p>Let‚Äôs try to walk through a mental model of how <code>pluck()</code> gets associated to the proper implementation.</p>

<p>```rust
// Given an HList (type explicitly declared for clarity)
let h: Hlist![ &amp;str, bool, f32, i32 ] = hlist![ ‚ÄúJoe‚Äù, false, 42f32, 9 ];</p>

<p>// Suppose we want to get the float (f32) value out
// We‚Äôre ignoring the remainder and its type (Rust will figure it out),
// because it isn‚Äôt relevant for now.
let (v, <em>): (f32,</em>) = h.pluck();
```</p>

<p>We‚Äôre ignoring the remainder and its type (Rust will figure it out if we use the underscore binding <code>_</code>), because it isn‚Äôt relevant for what we‚Äôre about to do.</p>

<p>In the following steps, we‚Äôll substitute concrete types into our implementations where possible; similar to how functions get bound to values during the <a href="http://www.cs.cornell.edu/courses/cs3110/2013sp/lectures/lec06-subst-model/lec06.html">substitution model of evaluation</a> (normally used for evaluating runtime values). We‚Äôll do this in steps, so it‚Äôs possible that in the earlier stages, we don‚Äôt quite know the concrete type yet, but we‚Äôll go down the ‚Äústack‚Äù, and come back up and fill those types in, too, once we know them.</p>

<ol>
  <li>
    <p><code>pluck()</code> on <code>Hlist![ &amp;str, bool, f32, i32 ]</code></p>

    <p>Since our <code>Target</code> type (<code>f32</code>) is not in the head, it doesn‚Äôt match with the <code>Here</code> case, so we will try to use the work-to-be-done case (<code>Index</code> is <code>There&lt;TailIndex&gt;</code>) and fill in as many types as we can for now. Let‚Äôs replace some type parameters with their concrete types where possible.</p>

    <p>Concrete types:</p>

    <ul>
      <li><code>Head</code> ‚Üí <code>&amp;str</code></li>
      <li><code>Tail</code> ‚Üí <code>Hlist![bool, f32, i32 ]</code> (remember, this is syntactic sugar for <code>HCons&lt;bool, HCons&lt;f32, HCons&lt;i32, HNil&gt;</code>)</li>
      <li><code>Target</code> ‚Üí <code>f32</code> (this doesn‚Äôt change)</li>
      <li><code>Remainder</code> ‚Üí Don‚Äôt know yet, but we already know that the current <code>Head</code> will be in it, since it isn‚Äôt the <code>target</code> type. And we know the tail of <code>Remainder</code> will be the remainder from <code>pluck()</code>ing <code>f32</code> from the tail, so we can reference it as <code>HCons&lt; &amp;str, &lt; Hlist![bool, f32, i32] as Plucker&lt;f32, There&lt;Here&gt;&gt; &gt;::Remainder &gt;</code> for now.</li>
      <li><code>TailIndex</code> ‚Üí Don‚Äôt know yet, but we‚Äôll find out. Let‚Äôs call reference it as <code>TailIndex1</code> for now.</li>
    </ul>
  </li>
  <li>
    <p><code>pluck()</code> on <code>Hlist![bool, f32, i32]</code> (<code>Tail</code> from 1.)</p>

    <p>Again, <code>f32</code> is not in the head of our type, so we know we aren‚Äôt going to be working with the exit-type typeclass implementation (e.g., <code>Index</code> is not <code>Here</code> yet.)</p>

    <p>Concrete types:</p>

    <ul>
      <li><code>Head</code> ‚Üí <code>bool</code></li>
      <li><code>Tail</code> ‚Üí <code>Hlist![ f32, i32 ]</code></li>
      <li><code>Target</code> ‚Üí <code>f32</code> (again, this doesn‚Äôt change)</li>
      <li><code>Remainder</code> ‚Üí Still don‚Äôt know yet, but we do know that <code>bool</code> will be in it since it isn‚Äôt our target. Similar to the previous step, we‚Äôll tentatively call it <code>HCons&lt; bool, &lt; Hlist![ f32, i32] as Plucker&lt;f32, Here&gt; &gt;::Remainder &gt;</code></li>
      <li><code>TailIndex</code> ‚Üí Don‚Äôt know yet, but let‚Äôs rename it <code>TailIndex2</code> for now and fill it in later.</li>
    </ul>
  </li>
  <li>
    <p><code>pluck()</code> on <code>Hlist![ f32, i32 ]</code> (<code>Tail</code> from 2.)</p>

    <p>The head has type <code>f32</code> and the target type is <code>f32</code>, so we‚Äôve arrived at the exit-type implementation.</p>

    <p>Concrete types:</p>

    <ul>
      <li><code>Head</code> ‚Üí <code>f32</code></li>
      <li><code>Tail</code> ‚Üí <code>Hlist![ i32 ]</code></li>
      <li><code>Target</code> ‚Üí <code>f32</code> !</li>
      <li><code>Remainder</code> ‚Üí Since we‚Äôve found our target, we know that <code>Remainder</code> must be the tail, and thus <code>Hlist![ i32 ]</code>, or its equivalent <code>HCons&lt; i32, HNil &gt;</code></li>
      <li><code>Index</code> ‚Üí <code>Here</code> !</li>
    </ul>
  </li>
</ol>

<p>Now, that we‚Äôve finally resolved a concrete type for <code>Index</code>, we can go backwards up the type-level stack and fill in our unknowns:</p>

<ul>
  <li>Step 2:
    <ul>
      <li><code>TailIndex2</code> ‚Üí <code>Here</code>, which means that <code>Index</code> is <code>There&lt;Here&gt;&gt;</code></li>
      <li><code>Remainder</code> ‚Üí <code>HList![ boo, i32 ]</code></li>
    </ul>
  </li>
  <li>Step 1:
    <ul>
      <li><code>TailIndex1</code> ‚Üí <code>There&lt;Here&gt;</code>, which means that <code>Index</code> is <code>There&lt;There&lt;Here&gt;&gt;&gt;</code></li>
      <li><code>Remainder</code> ‚Üí <code>HList![ &amp;str, boo, i32 ]</code></li>
    </ul>
  </li>
</ul>

<p>The compiler is thus able to find a trait implementation to <code>pluck()</code> a <code>f32</code> out of an <code>Hlist![ &amp;str, bool, f32, i32 ]</code> that looks like this (with all the type parameters bound to a concrete type):</p>

<p>```rust
// Remember Hlist![ ‚Ä¶ ] is just a type-macro to make it easier to write nested Hcons
impl Plucker&lt; f32, There&lt;There<here>&gt; &gt; for Hlist![ &amp;str, bool, f32, i32 ]
   where Hlist![ bool, f32, i32 ]: Plucker&lt; f32, There<here> &gt;
{
  type Remainder = HList![ &amp;str, boo, i32 ];</here></here></p>

<p>fn pluck(self) -&gt; (f32, Self::Remainder) {
    let (target, tail_remainder): (f32, &lt; Hlist![bool, f32, i32] as Plucker&lt;f32, There<here>&gt; &gt;::Remainder) =
      &lt; Hlist![ bool, f32, i32 ] as Plucker&lt;f32, There<here>&gt; &gt;::pluck(self.tail);
    (target,
     HCons {
         head: self.head,
         tail: tail_remainder,
     })
  }
}
```</here></here></p>

<p>Whew! That took a while, but I hope it helps illustrate how you can use a mental model similar to the substitution model of evaluation, but with types, in order to prove the existence of implementations for a given type.</p>

<p>By the way, by default, the compiler has a limit on how many levels of recursion/expansion this search for a typeclass instance goes. In my testing, I found this to be 64 levels and verified it to be so by looking at <a href="https://github.com/rust-lang/rust/blob/be304afc8c2b1a364bd406888b5378897ed82a9f/src/libsyntax/ext/expand.rs#L1122">Rust‚Äôs source code</a>. If you hit the limit, the compiler blow up, but will helpfully offer you a solution:</p>

<p><code>
error[E0275]: overflow evaluating the requirement `frunk_core::hlist::HNil: frunk_core::hlist::Plucker&lt;bool, _&gt;`
   --&gt; tests/derivation_tests.rs:296:35
    |
296 |     let (e, _): (bool, _) = hello.pluck();
    |                                   ^^^^^
    |
    = note: consider adding a `#![recursion_limit="128"]` attribute to your crate
    = note: required because of the requirements on the impl of `frunk_core::hlist::Plucker&lt;bool, frunk_core::hlist::There&lt;_&gt;&gt;` for `frunk_core::hlist::HCons&lt;bool, frunk_core::hlist::HNil&gt;`
</code></p>

<p>So, simply add <code>#![recursion_limit="128"]</code> to your crate. If you hit the limit again, the compiler will tell you to double the limit again. Ad infinitum.</p>

<h2 id="sculpting-hlists">Sculpting HLists</h2>

<p>Great ! Now that we‚Äôve finished with <code>Plucker</code>, let‚Äôs go one level deeper: making use of <code>Plucker</code> to do something even more interesting; sculpting <code>HList</code>s !</p>

<p>Here is the basic idea of what we want to be able to do:</p>

<p>```rust
// Given an HList of type Hlist![ i32, &amp;str, f32, bool ]
let h] = hlist![9000, ‚Äújoe‚Äù, 41f32, true];</p>

<p>// We‚Äôd like to be able to ‚Äúsculpt‚Äù it into another, differently shaped HList.
//
// Of course, the types in the new HList must be a subset of the original HList,
// and if not, compilation should fail.
//
// Similar to pluck(), we‚Äôd also want the remainder of the original HList <em>not</em>
// used in the final result.
let (reshaped, remainder): (Hlist![ f32, i32, &amp;str ], _) = h.sculpt();
assert_eq!(reshaped, hlist![41f32, 9000, ‚Äújoe‚Äù]);
assert_eq!(remainder, hlist![true]);</p>

<p>// the following should fail to compile, because there is no char in the original Hlist
let (reshaped, _) = (Hlist![char], _) = h.sculpt();
```</p>

<h3 id="implementation-intuition-1">Implementation intuition</h3>

<p>Let‚Äôs call our trait <code>Sculptor</code>. We should be able to re-use our <code>Plucker</code> trait, which which means we‚Äôll work with <code>Target</code>s and <code>Index</code>s, <em>but</em> there‚Äôs more than one of each!</p>

<p>Intuitively, this is the kind of logic that we want:</p>

<p>Given <code>TargetHList</code> (target HList) and <code>SourceHList</code> (source HList), and assuming the types in the former is a subset (not necessarily in order though) of the latter:</p>

<ol>
  <li>Pluck value with the head type of <code>TargetHList</code> from <code>SourceHList</code>:
    <ul>
      <li>Store the result in a <code>(plucked, remainder)</code> tuple</li>
    </ul>
  </li>
  <li>Call <code>sculpt</code> on <code>remainder</code>, passing the tail type of the current <code>TargetHList</code> as the new    <code>TargetHList</code> type.
    <ul>
      <li>Store the result in a <code>(sculpted_tail, sculpted_remainder)</code> tuple</li>
    </ul>
  </li>
  <li>Return <code>(HCons { head: plucked, tail: sculpted_tail }, sculpted_remainder)</code></li>
</ol>

<p>Note that in 1. we are making use of <code>pluck()</code>, and there is a recursive call to <code>sculpt()</code> in 2. Since there is a recursive call to <code>sculpt()</code>, it means that we need an exit-type as well. Intuitively, we‚Äôll pencil one in:</p>

<blockquote>
  <p>When the target HList is empty (HNil), return a tuple <code>(HNil, SourceHList)</code></p>
</blockquote>

<h3 id="first-attempt-1">First attempt</h3>

<p>Given our logic, let‚Äôs assume we want 4 type parameters in our trait. Our trait is a bit more complicated than our <code>Pluck</code> trait, but not by much. We make use of the same associated-type trick to hold the type of <code>Remainder</code> to be returned as the 2nd element in our type that will be filled-in when we write instances of the trait.</p>

<p>```rust
trait Sculptor&lt;Target, TargetTail, HeadIndex, TailIndices&gt; {</p>

<p>type Remainder;</p>

<p>fn sculpt(self) -&gt; (HCons&lt;Target, TargetTail&gt;, Self::Remainder);
}
```</p>

<p>The instance of <code>Sculptor</code> for the exit-type should be simple, right?:</p>

<p>```rust
// Our exit condition is when Target is HNil, so we don‚Äôt care about the tail of the target
// nor do we really care about the type of SourceHList
impl &lt;TargetTail, HeadIndex, TailIndices, SourceHList&gt; Sculptor&lt;HNil, TargetTail, HeadIndex, TailIndices&gt; for SourceHList {</p>

<pre><code>type Remainder = Source;

// ?!?!? HNil as the head type of an HCons doesn't make sense
fn sculpt(self) -&gt; (HCons&lt;HNil, TargetTail&gt;, Self::Remainder) {
    // nevermind
}
</code></pre>

<p>}
```</p>

<p>Ooops; that didn‚Äôt work; our type signature for the trait can‚Äôt be fulfilled when implementing our instance! We simply have too many type parameters in our trait, even for the exit-type implementation (try implementing for the recursion case‚Ä¶it‚Äôll become more apparent)</p>

<p>Back to the drawing board.</p>

<h3 id="second-attempt-1">Second attempt</h3>

<p>Let‚Äôs collapse our target-related type parameters into a single <code>Target</code> type parameter and our indices-related type parameters into a single <code>Indices</code> type parameter in our <code>Sculptor</code> trait declaration, and rely on the implementations to dictate (specialise) what types they should be (similar to how the <code>Plucker</code> trait had no mention of <code>There</code> or <code>Here</code>).</p>

<p>```rust
trait Sculptor&lt;Target, Indices&gt; {</p>

<pre><code>type Remainder;

fn sculpt(self) -&gt; (Target, Self::Remainder); } ```
</code></pre>

<p>The exit-type implementation will still be when we have <code>HNil</code> as the target. Thinking it through further, in the case that we don‚Äôt have a <code>HNil</code> as the target, it‚Äôs obvious that <code>Source</code> can then be literally anything, so we‚Äôll rename its type parameter <code>Source</code>. Since our intention for <code>Sculptor</code> is for <code>Indices</code> to be an HList of <code>Here</code> or <code>There&lt;A&gt;</code> (one for each type in our <code>Target</code> HList), the exit <code>Indices</code> must therefore be a valid Hlist. Since we don‚Äôt need an index to find an empty target, let‚Äôs make <code>Indices</code> <code>HNil</code> for simplicity.</p>

<p>```rust
impl<source /> Sculptor&lt;HNil, HNil&gt; for Source {
    // Since Our Target is HNil, we just return the Source
    type Remainder = Source;</p>

<pre><code>fn sculpt(self) -&gt; (HNil, Self::Remainder) {
    (HNil, self)
} } ```
</code></pre>

<p>To figure out the type parameters needed for our work-to-be-done type, let‚Äôs work through the logic we laid out earlier.</p>

<p>At minimum, we know we‚Äôre writing an instance of <code>Sculptor</code> for a Source of type HList, and our Target type is also an HList, so we‚Äôll use <code>SHead</code> and <code>STail</code> to describe the ‚ÄúSource‚Äù HList (so <code>HCons&lt;SHead, STail&gt;</code>), and <code>THead</code> and <code>TTail</code> to denote the ‚ÄúTarget‚Äù HList (similarly, <code>HCons&lt;THead, TTail&gt;</code>).</p>

<blockquote>
  <ol>
    <li>Pluck value with the head type of <code>TargetHList</code> from <code>SourceHList</code>:
      <ul>
        <li>Store the result in a <code>(plucked, remainder)</code> tuple</li>
      </ul>
    </li>
  </ol>
</blockquote>

<p>Since we need to <code>pluck()</code> a <code>THead</code> from our Source HList, we‚Äôll need a type parameter for the first index, so let‚Äôs name it <code>IndexHead</code>. In addition, in order to <code>pluck()</code>, we need a <code>Plucker</code> too, so this constraint is needed somewhere in our implementation declaration:</p>

<p><code>rust
 HCons&lt;SHead, STail&gt;: Plucker&lt;THead, IndexHead&gt;
</code></p>

<blockquote>
  <ol>
    <li>Call <code>sculpt()</code> on <code>remainder</code>, passing the tail type of the current <code>TargetHList</code> as the new <code>TargetHList</code> type.
      <ul>
        <li>Store the result in a <code>(sculpted_tail, sculpted_remainder)</code> tuple</li>
      </ul>
    </li>
  </ol>
</blockquote>

<p>Since we want to sculpt the remainder of calling <code>pluck()</code> in step 1. into type <code>TTail</code> (tail of <code>TargetHList</code>), we‚Äôll need to have an HList of indices for that purpose too, so let‚Äôs call it <code>IndexTail</code>. Note that we don‚Äôt need a separate type parameter for the remainder from 1 because we can take advantage of the associated type on <code>Plucker</code>.</p>

<p><code>rust
// In English, this is read as:
// "The remainder of plucking the Target head type (THead) out of the source HList
// must have a Sculptor implementation that lets us turn it into the tail type of
// the Target HList (TTail) using the tail of the current Indices (IndexTail)"
&lt;HCons&lt;SHead, STail&gt; as Plucker&lt;THead, IndexHead&gt;&gt;::Remainder: Sculptor&lt;TTail, IndexTail&gt;
</code></p>

<blockquote>
  <ol>
    <li>Return <code>(HCons { head: plucked, tail: sculpted_tail }, sculpted_remainder)</code></li>
  </ol>
</blockquote>

<p>What will the <code>Remainder</code> type be? It should be the remainder of sculpting the remainder from plucking the head type (<code>THead</code>) out of the current source HList into <code>TTail</code> (yeah‚Ä¶)</p>

<p><code>rust
type Remainder = &lt;&lt;HCons&lt;SHead, STail&gt; as Plucker&lt;THead, IndexHead&gt;&gt;::Remainder as Sculptor&lt;TTail, IndexTail&gt;&gt;::Remainder;
</code></p>

<p>Putting all these types together with the logic, we have</p>

<p>```rust
impl &lt;THead, TTail, SHead, STail, IndexHead, IndexTail&gt; Sculptor&lt;HCons&lt;THead, TTail&gt;, HCons&lt;IndexHead, IndexTail¬ª
    for HCons&lt;SHead, STail&gt;
    where
        HCons&lt;SHead, STail&gt;: Plucker&lt;THead, IndexHead&gt;,
        &lt;HCons&lt;SHead, STail&gt; as Plucker&lt;THead, IndexHead¬ª::Remainder: Sculptor&lt;TTail, IndexTail&gt; {</p>

<pre><code>type Remainder = &lt;&lt;HCons&lt;SHead, STail&gt; as Plucker&lt;THead, IndexHead&gt;&gt;::Remainder as Sculptor&lt;TTail, IndexTail&gt;&gt;::Remainder;

fn sculpt(self) -&gt; (HCons&lt;THead, TTail&gt;, Self::Remainder) {
    let (p, r): (THead, &lt;HCons&lt;SHead, STail&gt; as Plucker&lt;THead, IndexHead&gt;&gt;::Remainder) = self.pluck();
    let (tail, tail_remainder): (TTail, Self::Remainder) = r.sculpt();
    (
        HCons {
            head: p,
            tail: tail
        },
        tail_remainder
    )
}
</code></pre>

<p>}
```</p>

<p>As you can see, our implementations of <code>Sculptor</code> is type-recursive in an interesting way, and there are quite a few dependencies that need to be worked out between all the type parameters and the <code>Plucker</code> trait <em>as well as</em> the <code>Sculptor</code> trait itself (it appears in the <code>where</code> after all). Fortunately, the Rust compiler will do that for us (and if need be, tell you to raise the <code>#![recursion_limit]</code> in your crate).</p>

<p>If you‚Äôre not convinced this works, please by all means check out the <a href="https://beachape.com/frunk/frunk_core/hlist/index.html"><code>hlist</code> module</a> in Frunk, in particular the <a href="https://beachape.com/frunk/frunk_core/hlist/trait.Sculptor.html">Sculptor trait</a>.</p>

<h2 id="conclusion">Conclusion</h2>

<p>One last thing: the <code>Plucker</code> and <code>Sculptor</code> things aren‚Äôt just cute exercises; <code>Plucker</code> has already paid dividends when modeling <code>Sculptor</code>, and <code>Sculptor</code>, well, it‚Äôs instrumental in letting us do cool stuff like convert between structs with different <a href="/blog/2017/03/04/labelledgeneric-in-rust-what-why-how/">LabelledGeneric implementations</a> (to an extent, anyways), and other, even cooler generic functions. We‚Äôll talk more about this in <a href="/blog/2017/04/12/boilerplate-free-struct-transforms-in-rust/">another post</a>.</p>

<p>If you do a search, you‚Äôll find a number of articles on the Interwebs that introduce Rust‚Äôs trait system, but not many that go deep into how to use it when you need to do non-trivial type-level recursion in your trait implementations (though how often this need arises is ‚Ä¶ another topic altogether). I also find that people generally don‚Äôt talk about what they did <em>wrong</em>, so I wanted to share my failed approaches as well.</p>

<p>The goal of this post is to hopefully help others who are curious, or have a need to do something similar, as well as to leave notes for myself in case I ever need to revisit this in the future. The mental models for breaking down the problem, defining types, and building up to an implementation might not work for everyone, but they‚Äôve helped me.</p>

<p>Personally, I think it‚Äôs awesome that a close-to-the-metal systems programming language like Rust has a powerful enough compiler and type-system to allow for these kinds of techniques. As you can see, we‚Äôve managed to build powerful, reusable abstractions without doing anything unsafe, and we‚Äôve exposed an API that requires just the bare minimum of type annotations; Rust infers the rest :) In any case, I hope this post was useful, and as usual, please chime in with questions and suggestions.</p>

<h3 id="credit">Credit</h3>
<ol>
  <li>The <code>Here</code> and <code>There&lt;A&gt;</code> design was largely gleaned from <a href="https://github.com/Sgeo/hlist/blob/master/src/lib.rs#L30">this code</a>. I stand on the shoulders of giants :)</li>
</ol>

<p>** It goes without saying that these operations need to be type-safe. That is, they are verified by the compiler without using any unsafe tricks that could blow up at runtime.</p>
]]></content>
  </entry>
  
</feed>
