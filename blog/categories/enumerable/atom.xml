<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Enumerable | BeachApe.]]></title>
  <link href="https://beachape.com/blog/categories/enumerable/atom.xml" rel="self"/>
  <link href="https://beachape.com/"/>
  <updated>2017-03-06T21:18:50+09:00</updated>
  <id>https://beachape.com/</id>
  <author>
    <name><![CDATA[Lloyd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby 2.0.0 Enumerable Lazy Benchmark]]></title>
    <link href="https://beachape.com/blog/2013/06/12/ruby-2-dot-0-0-enumerable-lazy-benchmark/"/>
    <updated>2013-06-12T10:30:00+09:00</updated>
    <id>https://beachape.com/blog/2013/06/12/ruby-2-dot-0-0-enumerable-lazy-benchmark</id>
    <content type="html"><![CDATA[<p>Ruby 2.0.0 was released a few months back and I finally had some time to look into some of the features and changes that came with it. Lazy collections has always been a cool concept for me and so I decided to do a few benchmarks.</p>

<!-- more -->

<p>That said, a quick Google search brought me to this <a href="http://dev.af83.com/2012/11/22/ruby-2-0-enumerator-lazy.html">great page</a> where someone had already written a usable benchmark back in 2012 when the 2.0.0 preview release came out:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>Benchmark (ruby_2_0_0_enum_lazy_bench.rb)</span> <a href='/downloads/code/ruby/ruby_2_0_0_enum_lazy_bench.rb'>download</a></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='rb'><span class='line'><span></span><span class="nb">require</span> <span class="s1">&#39;benchmark&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="o">[</span><span class="mi">10000</span><span class="p">,</span> <span class="mi">100000</span><span class="p">,</span> <span class="mi">1000000</span><span class="p">,</span> <span class="mi">10000000</span><span class="o">].</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">size</span><span class="o">|</span>
</span><span class='line'>  <span class="no">Benchmark</span><span class="o">.</span><span class="n">bm</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">b</span><span class="o">|</span>
</span><span class='line'>    <span class="n">b</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s2">&quot;chainable </span><span class="si">#{</span><span class="n">size</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="k">do</span>
</span><span class='line'>      <span class="n">hashes</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="n">size</span><span class="p">)</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:even?</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:hash</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:to_s</span><span class="p">)</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="no">Benchmark</span><span class="o">.</span><span class="n">bm</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">b</span><span class="o">|</span>
</span><span class='line'>    <span class="n">b</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s2">&quot;one iteration </span><span class="si">#{</span><span class="n">size</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="k">do</span>
</span><span class='line'>      <span class="n">hashes</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="n">size</span><span class="p">)</span><span class="o">.</span><span class="n">inject</span><span class="p">(</span><span class="o">[]</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">accumulator</span><span class="p">,</span> <span class="n">number</span><span class="o">|</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">number</span><span class="o">.</span><span class="n">even?</span>
</span><span class='line'>          <span class="n">accumulator</span> <span class="o">&lt;&lt;</span> <span class="n">number</span><span class="o">.</span><span class="n">hash</span><span class="o">.</span><span class="n">to_s</span>
</span><span class='line'>        <span class="k">else</span>
</span><span class='line'>          <span class="n">accumulator</span>
</span><span class='line'>        <span class="k">end</span>
</span><span class='line'>      <span class="k">end</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="no">Benchmark</span><span class="o">.</span><span class="n">bm</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">b</span><span class="o">|</span>
</span><span class='line'>    <span class="n">b</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s2">&quot;chainable lazy </span><span class="si">#{</span><span class="n">size</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="k">do</span>
</span><span class='line'>      <span class="n">hashes</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="n">size</span><span class="p">)</span><span class="o">.</span><span class="n">lazy</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:even?</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:hash</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:to_s</span><span class="p">)</span><span class="o">.</span><span class="n">to_a</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>And then the results, with Ruby 2.0.0p0</p>

<p><code>
                      user     system      total        real
chainable 10000   0.000000   0.000000   0.000000 (  0.002659)
                      user     system      total        real
one iteration 10000  0.000000   0.000000   0.000000 (  0.002732)
                      user     system      total        real
chainable lazy 10000  0.010000   0.000000   0.010000 (  0.005103)
                      user     system      total        real
chainable 100000  0.030000   0.000000   0.030000 (  0.031249)
                      user     system      total        real
one iteration 100000  0.020000   0.000000   0.020000 (  0.027257)
                      user     system      total        real
chainable lazy 100000  0.060000   0.000000   0.060000 (  0.053770)
                      user     system      total        real
chainable 1000000  0.260000   0.010000   0.270000 (  0.270027)
                      user     system      total        real
one iteration 1000000  0.280000   0.010000   0.290000 (  0.283680)
                      user     system      total        real
chainable lazy 1000000  0.560000   0.010000   0.570000 (  0.566137)
                      user     system      total        real
chainable 10000000  2.830000   0.120000   2.950000 (  2.956604)
                      user     system      total        real
one iteration 10000000  2.910000   0.130000   3.040000 (  3.095763)
                      user     system      total        real
chainable lazy 10000000  5.580000   0.140000   5.720000 (  6.079247)
</code></p>

<h2 id="conclusion">Conclusion</h2>
<p>Turns out that performance of Lazy relative to non-lazy variants hasn’t changed enough for it to be worthwhile to use for anything other than outrageously huge colletions (perhaps many many times larger than 10000000) from a performance point of view. That said, depending on the operation you’re performing, using Lazy might be useful if you want to play within memory constraints.</p>
]]></content>
  </entry>
  
</feed>
