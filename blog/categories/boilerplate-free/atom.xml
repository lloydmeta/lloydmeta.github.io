<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Boilerplate-free | BeachApe.]]></title>
  <link href="https://beachape.com/blog/categories/boilerplate-free/atom.xml" rel="self"/>
  <link href="https://beachape.com/"/>
  <updated>2017-05-30T02:41:04+09:00</updated>
  <id>https://beachape.com/</id>
  <author>
    <name><![CDATA[Lloyd]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Boilerplate-free Struct Transforms in Rust.]]></title>
    <link href="https://beachape.com/blog/2017/04/12/boilerplate-free-struct-transforms-in-rust/"/>
    <updated>2017-04-12T12:45:00+09:00</updated>
    <id>https://beachape.com/blog/2017/04/12/boilerplate-free-struct-transforms-in-rust</id>
    <content type="html"><![CDATA[<p>The last several posts have introduced a number of abstractions, namely HList, Generic, LabelledGeneric, as well as <code>pluck()</code> and <code>sculpt()</code>. Although each of those have impressive party tricks of their own, I’d like to share how you can use them to write a reuseable, generic function that handles converting between structs with mis-matched fields and thus have different <code>LabelledGeneric</code> representations.</p>

<p><img class="center" src="/images/optimus-prime.gif" title="‘All together now’" ></p>

<p>Unlike the last post, this one will be relatively light on recursion and mind-bending type-level stuff; it’s time to sit back and enjoy the fruits of our labour.</p>

<!-- more -->

<h2 id="adding-frunk-to-your-project">Adding Frunk to your project</h2>

<p>Much of this post will make use of <a href="https://github.com/lloydmeta/frunk">Frunk’s</a> types (e.g. <code>HCons</code>, <code>HNil</code>), methods, macros (esp. for describing macro types via the <code>Hlist!</code> <a href="https://beachape.com/frunk/frunk_core/macro.Hlist.html">type macro</a>), and terminology.</p>

<p>It might be easier to follow along if you add Frunk to your project and play around with it. <a href="https://github.com/lloydmeta/frunk">Frunk</a> is published to <a href="//crates.io/crates/frunk">Crates.io</a>, so to add it your list of dependencies, simply put this in your <code>Cargo.toml</code>:</p>

<p><a href="https://crates.io/crates/frunk"><img src="https://img.shields.io/crates/v/frunk.svg" alt="Crates.io" /></a></p>

<p><code>rust
[dependencies]
frunk = "${latest_version}"
</code></p>

<p>Alternatively, take a look at the <a href="https://beachape.com/frunk">published Rustdocs</a>.</p>

<h2 id="boilerplate-free-conversions-between-structs">Boilerplate-free conversions between Structs</h2>

<p>Suppose we have a bunch of structs that are similar-ish in terms of their data but ultimately, not necessarily
exactly the same. This means we can’t just use the normal <code>LabelledGeneric</code> <code>convert_from</code> method to convert between them.</p>

<p>```rust
#[derive(LabelledGeneric)]
struct UserFromDb&lt;’a&gt; {
    id: u64,
    first_name: &amp;’a str,
    last_name: &amp;’a str,
    email: &amp;’a str,
    age: u32,
    pw_hash: &amp;’a str,
    is_admin: bool,
    created_at: i64
}</p>

<p>// Holds User data for rendering in a front-end view
// or for sending over an API. Striped of any sensitive
// information
#[derive(LabelledGeneric)]
struct PresentableUser&lt;’a&gt; {
    last_name: &amp;’a str,
    first_name: &amp;’a str,
    age: u32,
    created_at: i64
}</p>

<p>// Holds data for sending a User over our internal API
#[derive(LabelledGeneric)]
struct InternalApiUser&lt;’a&gt; {
    id: u64,
    first_name: &amp;’a str,
    last_name: &amp;’a str,
    age: u32,
    email: &amp;’a str,
    is_admin: bool,
    created_at: i64
}
```</p>

<p>In our example, <code>PresentableUser</code> and <code>InternalApiUser</code> structs have fields that are subsets of the fields in <code>UserFromDb</code>, and not in the same order either. The scenario is that <code>UserFromDb</code> is a struct that we get from reading our persistence layer, and the other 2 are types that we use in our application for business logic.</p>

<p>Assuming a flow where we want to be able to go from <code>UserFromDb</code> to either <code>PresentableUser</code> or <code>InternalApiUser</code>, the idea is that we don’t want be holding on to sensitive data like <code>pw_hash</code> when we don’t need to, thus lowering the risk of accidentally leaking said data (e.g. serialising it by accident, or by rendering it in debug messages, etc).</p>

<p>While we could go about writing <code>From</code>s by hand for each of these, and for every other time a similar situation arises, that’s quite a lot of boilerplate to write and maintain. Thankfully, we can make use of Frunk’s <code>LabelledGeneric</code> and <code>Sculptor</code> to write a single, reuseable generic function.</p>

<p>Note, for a review of:</p>

<ul>
  <li><code>LabelledGeneric</code>, see <a href="/blog/2017/03/04/labelledgeneric-in-rust-what-why-how/">this post</a></li>
  <li><code>Sculptor</code>, see <a href="/blog/2017/03/12/gentle-intro-to-type-level-recursion-in-Rust-from-zero-to-frunk-hlist-sculpting/">this post</a></li>
</ul>

<p><code>rust
/// Converts from another type A into B assuming that A and B have labelled generic representations
/// that can be sculpted into each other.
///
/// Note that this method tosses away the "remainder" of the sculpted representation.
fn transform_from&lt;A, B, Indices&gt;(a: A) -&gt; B
    where A: LabelledGeneric,
          B: LabelledGeneric,
// The labelled representation of A must be sculpt-able into the labelled representation of Self
          &lt;A as LabelledGeneric&gt;::Repr: Sculptor&lt;&lt;B as LabelledGeneric&gt;::Repr, Indices&gt; {
    // Turn A into its labelled generic representation
    let a_gen = &lt;A as LabelledGeneric&gt;::into(a);
    // Sculpt the generic labelled representation of A into the labelled generic representation
    // of B. We ignore the remainder.
    let (b_gen, _): (&lt;B as LabelledGeneric&gt;::Repr, _) = a_gen.sculpt();
    // Turn the lablled generic representation of B into B
    &lt;B as LabelledGeneric&gt;::from(b_gen)
}
</code></p>

<p>Not bad. The body of the function is literally 3 lines long :) Now we can do this:</p>

<p>```rust
let u_db = UserFromDb {
    id: 3,
    first_name: “Joe”,
    last_name: “Blow”,
    email: “joe@gmail.com”,
    age: 30,
    pw_hash: “asd35235adsf”,
    is_admin: true,
    created_at: 12345,
};</p>

<p>let p_user: PresentableUser = transform_from(udb);
// or
let i_user: InternalApiUser = transform_from(udb);
```</p>

<p>In actuality, Frunk already <a href="https://beachape.com/frunk/frunk_core/labelled/fn.transform_from.html">ships with this function</a> so you can use it out of the box.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Often times, you’ll hear that heterogeneous lists enable developers to write reuseable generic functions because they abstract over arity and types, and it might not be obvious exactly what that means on a practical level. The example shown in this post just scratches the surface of what is made possible through <code>HList</code> and <code>LabelledGeneric</code>, and there are definitely more creative usages out there, such as building of boilerplate-free (e.g. JSON) codecs (hint: look to Haskell and Scala libs for more).</p>

<p>As usual, please give it a spin and chime in with any questions, corrections, and suggestions !</p>
]]></content>
  </entry>
  
</feed>
